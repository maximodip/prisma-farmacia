/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-pages-internals"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-page.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-segment.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/not-found-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/metadata/metadata-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-boundary.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRm1heCUyRmRldiUyRnByaXNtYS1mYXJtYWNpYSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmNsaWVudC1wYWdlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZtYXglMkZkZXYlMkZwcmlzbWEtZmFybWFjaWElMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZjbGllbnQtc2VnbWVudC5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGbWF4JTJGZGV2JTJGcHJpc21hLWZhcm1hY2lhJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGZXJyb3ItYm91bmRhcnkuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRm1heCUyRmRldiUyRnByaXNtYS1mYXJtYWNpYSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmxheW91dC1yb3V0ZXIuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRm1heCUyRmRldiUyRnByaXNtYS1mYXJtYWNpYSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRm5vdC1mb3VuZC1ib3VuZGFyeS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGbWF4JTJGZGV2JTJGcHJpc21hLWZhcm1hY2lhJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGbWF4JTJGZGV2JTJGcHJpc21hLWZhcm1hY2lhJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZsaWIlMkZtZXRhZGF0YSUyRm1ldGFkYXRhLWJvdW5kYXJ5LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsa1BBQTBIO0FBQzFIO0FBQ0Esd1BBQTZIO0FBQzdIO0FBQ0Esd1BBQTZIO0FBQzdIO0FBQ0Esc1BBQTRIO0FBQzVIO0FBQ0EsZ1FBQWlJO0FBQ2pJO0FBQ0Esb1JBQTJJO0FBQzNJO0FBQ0Esb1BBQTJIIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1wYWdlLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1zZWdtZW50LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2Vycm9yLWJvdW5kYXJ5LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kLWJvdW5kYXJ5LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-boundary.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/lib/metadata/metadata-boundary.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    MetadataBoundary: function() {\n        return MetadataBoundary;\n    },\n    OutletBoundary: function() {\n        return OutletBoundary;\n    },\n    ViewportBoundary: function() {\n        return ViewportBoundary;\n    }\n});\nconst _metadataconstants = __webpack_require__(/*! ./metadata-constants */ \"(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-constants.js\");\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n    [_metadataconstants.METADATA_BOUNDARY_NAME]: function(param) {\n        let { children } = param;\n        return children;\n    },\n    [_metadataconstants.VIEWPORT_BOUNDARY_NAME]: function(param) {\n        let { children } = param;\n        return children;\n    },\n    [_metadataconstants.OUTLET_BOUNDARY_NAME]: function(param) {\n        let { children } = param;\n        return children;\n    }\n};\nconst MetadataBoundary = // We use slice(0) to trick the bundler into not inlining/minifying the function\n// so it retains the name inferred from the namespace object\nNameSpace[_metadataconstants.METADATA_BOUNDARY_NAME.slice(0)];\nconst ViewportBoundary = // We use slice(0) to trick the bundler into not inlining/minifying the function\n// so it retains the name inferred from the namespace object\nNameSpace[_metadataconstants.VIEWPORT_BOUNDARY_NAME.slice(0)];\nconst OutletBoundary = // We use slice(0) to trick the bundler into not inlining/minifying the function\n// so it retains the name inferred from the namespace object\nNameSpace[_metadataconstants.OUTLET_BOUNDARY_NAME.slice(0)];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGLENBQUMsS0FBS0MsQ0FJTixDQUFDLENBQUM7QUFDRixTQUFTSSxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtJQUMxQixJQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxDQUFDVixNQUFNLENBQUNDLGNBQWMsQ0FBQ1EsTUFBTSxFQUFFRSxJQUFJLEVBQUU7UUFDcERDLFVBQVUsRUFBRSxJQUFJO1FBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtJQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNOLE9BQU8sRUFBRTtJQUNiRyxnQkFBZ0IsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDekIsT0FBT0EsZ0JBQWdCO0lBQzNCLENBQUM7SUFDREMsY0FBYyxFQUFFLFNBQUFBLENBQUEsRUFBVztRQUN2QixPQUFPQSxjQUFjO0lBQ3pCLENBQUM7SUFDREMsZ0JBQWdCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO1FBQ3pCLE9BQU9BLGdCQUFnQjtJQUMzQjtBQUNKLENBQUMsQ0FBQztBQUNGLE1BQU1PLGtCQUFrQixHQUFHQyxtQkFBTyxDQUFDLDZHQUFzQixDQUFDO0FBQzFEO0FBQ0E7QUFDQSxNQUFNQyxTQUFTLEdBQUc7SUFDZCxDQUFDRixrQkFBa0IsQ0FBQ0csc0JBQXNCLEdBQUc7Y0FBV0MsUUFBQUEsRUFBVSxFQUFFLENBQWQ7UUFDbEQsT0FBT0EsUUFBUTtJQUNuQixDQUFDO0lBQ0QsQ0FBQ0osa0JBQWtCLENBQUNLLHNCQUFzQixHQUFHO2NBQVdELFFBQUFBLEVBQVUsRUFBRSxDQUFkO1FBQ2xELE9BQU9BLFFBQVE7SUFDbkIsQ0FBQztJQUNELENBQUNKLGtCQUFrQixDQUFDTSxvQkFBb0IsR0FBRztjQUFXRixRQUFBQSxFQUFVLEVBQUUsQ0FBZDtRQUNoRCxPQUFPQSxRQUFRO0lBQ25CO0FBQ0osQ0FBQztBQUNELE1BQU1iLGdCQUFnQixHQUFHO0FBQ3pCO0FBQ0FXLFNBQVMsQ0FBQ0Ysa0JBQWtCLENBQUNHLHNCQUFzQixDQUFDSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0QsTUFBTWQsZ0JBQWdCLEdBQUc7QUFDekI7QUFDQVMsU0FBUyxDQUFDRixrQkFBa0IsQ0FBQ0ssc0JBQXNCLENBQUNFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RCxNQUFNZixjQUFjLEdBQUc7QUFDdkI7QUFDQVUsU0FBUyxDQUFDRixrQkFBa0IsQ0FBQ00sb0JBQW9CLENBQUNDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsiL2hvbWUvbWF4L2Rldi9wcmlzbWEtZmFybWFjaWEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvbWV0YWRhdGEvbWV0YWRhdGEtYm91bmRhcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWV0YWRhdGFCb3VuZGFyeTogbnVsbCxcbiAgICBPdXRsZXRCb3VuZGFyeTogbnVsbCxcbiAgICBWaWV3cG9ydEJvdW5kYXJ5OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIE1ldGFkYXRhQm91bmRhcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWV0YWRhdGFCb3VuZGFyeTtcbiAgICB9LFxuICAgIE91dGxldEJvdW5kYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE91dGxldEJvdW5kYXJ5O1xuICAgIH0sXG4gICAgVmlld3BvcnRCb3VuZGFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBWaWV3cG9ydEJvdW5kYXJ5O1xuICAgIH1cbn0pO1xuY29uc3QgX21ldGFkYXRhY29uc3RhbnRzID0gcmVxdWlyZShcIi4vbWV0YWRhdGEtY29uc3RhbnRzXCIpO1xuLy8gV2UgdXNlIGEgbmFtZXNwYWNlIG9iamVjdCB0byBhbGxvdyB1cyB0byByZWNvdmVyIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuLy8gYXQgcnVudGltZSBldmVuIHdoZW4gcHJvZHVjdGlvbiBidW5kbGluZy9taW5pZmljYXRpb24gaXMgdXNlZC5cbmNvbnN0IE5hbWVTcGFjZSA9IHtcbiAgICBbX21ldGFkYXRhY29uc3RhbnRzLk1FVEFEQVRBX0JPVU5EQVJZX05BTUVdOiBmdW5jdGlvbih7IGNoaWxkcmVuIH0pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH0sXG4gICAgW19tZXRhZGF0YWNvbnN0YW50cy5WSUVXUE9SVF9CT1VOREFSWV9OQU1FXTogZnVuY3Rpb24oeyBjaGlsZHJlbiB9KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9LFxuICAgIFtfbWV0YWRhdGFjb25zdGFudHMuT1VUTEVUX0JPVU5EQVJZX05BTUVdOiBmdW5jdGlvbih7IGNoaWxkcmVuIH0pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbn07XG5jb25zdCBNZXRhZGF0YUJvdW5kYXJ5ID0gLy8gV2UgdXNlIHNsaWNlKDApIHRvIHRyaWNrIHRoZSBidW5kbGVyIGludG8gbm90IGlubGluaW5nL21pbmlmeWluZyB0aGUgZnVuY3Rpb25cbi8vIHNvIGl0IHJldGFpbnMgdGhlIG5hbWUgaW5mZXJyZWQgZnJvbSB0aGUgbmFtZXNwYWNlIG9iamVjdFxuTmFtZVNwYWNlW19tZXRhZGF0YWNvbnN0YW50cy5NRVRBREFUQV9CT1VOREFSWV9OQU1FLnNsaWNlKDApXTtcbmNvbnN0IFZpZXdwb3J0Qm91bmRhcnkgPSAvLyBXZSB1c2Ugc2xpY2UoMCkgdG8gdHJpY2sgdGhlIGJ1bmRsZXIgaW50byBub3QgaW5saW5pbmcvbWluaWZ5aW5nIHRoZSBmdW5jdGlvblxuLy8gc28gaXQgcmV0YWlucyB0aGUgbmFtZSBpbmZlcnJlZCBmcm9tIHRoZSBuYW1lc3BhY2Ugb2JqZWN0XG5OYW1lU3BhY2VbX21ldGFkYXRhY29uc3RhbnRzLlZJRVdQT1JUX0JPVU5EQVJZX05BTUUuc2xpY2UoMCldO1xuY29uc3QgT3V0bGV0Qm91bmRhcnkgPSAvLyBXZSB1c2Ugc2xpY2UoMCkgdG8gdHJpY2sgdGhlIGJ1bmRsZXIgaW50byBub3QgaW5saW5pbmcvbWluaWZ5aW5nIHRoZSBmdW5jdGlvblxuLy8gc28gaXQgcmV0YWlucyB0aGUgbmFtZSBpbmZlcnJlZCBmcm9tIHRoZSBuYW1lc3BhY2Ugb2JqZWN0XG5OYW1lU3BhY2VbX21ldGFkYXRhY29uc3RhbnRzLk9VVExFVF9CT1VOREFSWV9OQU1FLnNsaWNlKDApXTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEtYm91bmRhcnkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiTWV0YWRhdGFCb3VuZGFyeSIsIk91dGxldEJvdW5kYXJ5IiwiVmlld3BvcnRCb3VuZGFyeSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9tZXRhZGF0YWNvbnN0YW50cyIsInJlcXVpcmUiLCJOYW1lU3BhY2UiLCJNRVRBREFUQV9CT1VOREFSWV9OQU1FIiwiY2hpbGRyZW4iLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiT1VUTEVUX0JPVU5EQVJZX05BTUUiLCJzbGljZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/scheduler.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  atLeastOneTask: function () {\n    return atLeastOneTask;\n  },\n  scheduleImmediate: function () {\n    return scheduleImmediate;\n  },\n  scheduleOnNextTick: function () {\n    return scheduleOnNextTick;\n  },\n  waitAtLeastOneReactRenderTask: function () {\n    return waitAtLeastOneReactRenderTask;\n  }\n});\nconst scheduleOnNextTick = cb => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (false) {} else {\n      process.nextTick(cb);\n    }\n  });\n};\nconst scheduleImmediate = cb => {\n  if (false) {} else {\n    setImmediate(cb);\n  }\n};\nfunction atLeastOneTask() {\n  return new Promise(resolve => scheduleImmediate(resolve));\n}\nfunction waitAtLeastOneReactRenderTask() {\n  if (false) {} else {\n    return new Promise(r => setImmediate(r));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3NjaGVkdWxlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsQ0FBQyxLQUFLQyxDQUtMLENBQUM7QUFDRixTQUFTSyxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixLQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxFQUFDWCxNQUFNLENBQUNDLGNBQWMsQ0FBQ1MsTUFBTSxFQUFFRSxJQUFJLEVBQUU7SUFDcERDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNQLE9BQU8sRUFBRTtFQUNiRyxjQUFjLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ3ZCLE9BQU9BLGNBQWM7RUFDekIsQ0FBQztFQUNEQyxpQkFBaUIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDMUIsT0FBT0EsaUJBQWlCO0VBQzVCLENBQUM7RUFDREMsa0JBQWtCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQzNCLE9BQU9BLGtCQUFrQjtFQUM3QixDQUFDO0VBQ0RDLDZCQUE2QixFQUFFLFNBQUFBLENBQUEsRUFBVztJQUN0QyxPQUFPQSw2QkFBNkI7RUFDeEM7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNRCxrQkFBa0IsR0FBSVEsRUFBRSxJQUFHO0VBQzdCO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDLENBQUNDLElBQUksQ0FBQyxNQUFJO0lBQ3ZCLElBQUlDLEtBQW1DLEVBQUUsRUFFeEMsTUFBTTtNQUNIQSxPQUFPLENBQUNJLFFBQVEsQ0FBQ1IsRUFBRSxDQUFDO0lBQ3hCO0VBQ0osQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUNELE1BQU1ULGlCQUFpQixHQUFJUyxFQUFFLElBQUc7RUFDNUIsSUFBSUksS0FBbUMsRUFBRSxFQUV4QyxNQUFNO0lBQ0hLLFlBQVksQ0FBQ1QsRUFBRSxDQUFDO0VBQ3BCO0FBQ0osQ0FBQztBQUNELFNBQVNWLGNBQWNBLENBQUEsRUFBRztFQUN0QixPQUFPLElBQUlXLE9BQU8sQ0FBRUMsT0FBTyxJQUFHWCxpQkFBaUIsQ0FBQ1csT0FBTyxDQUFDLENBQUM7QUFDN0Q7QUFDQSxTQUFTVCw2QkFBNkJBLENBQUEsRUFBRztFQUNyQyxJQUFJVyxLQUFtQyxFQUFFLEVBRXhDLE1BQU07SUFDSCxPQUFPLElBQUlILE9BQU8sQ0FBRVMsQ0FBQyxJQUFHRCxZQUFZLENBQUNDLENBQUMsQ0FBQyxDQUFDO0VBQzVDO0FBQ0oiLCJzb3VyY2VzIjpbIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3NjaGVkdWxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGF0TGVhc3RPbmVUYXNrOiBudWxsLFxuICAgIHNjaGVkdWxlSW1tZWRpYXRlOiBudWxsLFxuICAgIHNjaGVkdWxlT25OZXh0VGljazogbnVsbCxcbiAgICB3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzazogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBhdExlYXN0T25lVGFzazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhdExlYXN0T25lVGFzaztcbiAgICB9LFxuICAgIHNjaGVkdWxlSW1tZWRpYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlSW1tZWRpYXRlO1xuICAgIH0sXG4gICAgc2NoZWR1bGVPbk5leHRUaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlT25OZXh0VGljaztcbiAgICB9LFxuICAgIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrO1xuICAgIH1cbn0pO1xuY29uc3Qgc2NoZWR1bGVPbk5leHRUaWNrID0gKGNiKT0+e1xuICAgIC8vIFdlIHVzZSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCkgaGVyZSBzbyB0aGF0IHRoZSBvcGVyYXRpb24gaXMgc2NoZWR1bGVkIGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgcHJvbWlzZSBqb2IgcXVldWUsIHdlIHRoZW4gYWRkIGl0IHRvIHRoZSBuZXh0IHByb2Nlc3MgdGlja1xuICAgIC8vIHRvIGVuc3VyZSBpdCdzIGV2YWx1YXRlZCBhZnRlcndhcmRzLlxuICAgIC8vXG4gICAgLy8gVGhpcyB3YXMgaW5zcGlyZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBEYXRhTG9hZGVyIGludGVyZmFjZTogaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZGF0YWxvYWRlci9ibG9iL2QzMzZiZDE1MjgyNjY0ZTBiZTRiNGE2NTdjYjc5NmYwOWJhZmJjNmIvc3JjL2luZGV4LmpzI0wyMTMtTDI1NVxuICAgIC8vXG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBzY2hlZHVsZUltbWVkaWF0ZSA9IChjYik9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gYXRMZWFzdE9uZVRhc2soKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+c2NoZWR1bGVJbW1lZGlhdGUocmVzb2x2ZSkpO1xufVxuZnVuY3Rpb24gd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2soKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSA9PT0gJ2VkZ2UnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocik9PnNldFRpbWVvdXQociwgMCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocik9PnNldEltbWVkaWF0ZShyKSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiYXRMZWFzdE9uZVRhc2siLCJzY2hlZHVsZUltbWVkaWF0ZSIsInNjaGVkdWxlT25OZXh0VGljayIsIndhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwic2V0VGltZW91dCIsIm5leHRUaWNrIiwic2V0SW1tZWRpYXRlIiwiciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createDedupedByCallsiteServerErrorLoggerDev\", ({\n  enumerable: true,\n  get: function () {\n    return createDedupedByCallsiteServerErrorLoggerDev;\n  }\n}));\nconst _react = /*#__PURE__*/_interop_require_wildcard(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {\n    __proto__: null\n  };\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst errorRef = {\n  current: null\n};\n// React.cache is currently only available in canary/experimental React channels.\nconst cache = typeof _react.cache === 'function' ? _react.cache : fn => fn;\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn =  false ? 0 : console.warn;\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\nkey => {\n  try {\n    logErrorOrWarn(errorRef.current);\n  } finally {\n    errorRef.current = null;\n  }\n});\nfunction createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\n  return function logDedupedError(...args) {\n    const message = getMessage(...args);\n    if (true) {\n      var _stack;\n      const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message);\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4];\n        errorRef.current = message;\n        flushCurrentErrorIfNew(key);\n      }\n    } else {}\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILCtFQUE4RTtFQUMxRUksVUFBVSxFQUFFLElBQUk7RUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDWixPQUFPQywyQ0FBMkM7RUFDdEQ7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxNQUFNLEdBQUcsYUFBY0MseUJBQXlCLENBQUNDLG1CQUFPLENBQUMsbUZBQU8sQ0FBQyxDQUFDO0FBQ3hFLFNBQVNDLHdCQUF3QkEsQ0FBQ0MsV0FBVyxFQUFFO0VBQzNDLElBQUksT0FBT0MsT0FBTyxLQUFLLFVBQVUsRUFBRSxPQUFPLElBQUk7RUFDOUMsSUFBSUMsaUJBQWlCLEdBQUcsSUFBSUQsT0FBTyxDQUFDLENBQUM7RUFDckMsSUFBSUUsZ0JBQWdCLEdBQUcsSUFBSUYsT0FBTyxDQUFDLENBQUM7RUFDcEMsT0FBTyxDQUFDRix3QkFBd0IsR0FBRyxTQUFBQSxDQUFTQyxXQUFXLEVBQUU7SUFDckQsT0FBT0EsV0FBVyxHQUFHRyxnQkFBZ0IsR0FBR0QsaUJBQWlCO0VBQzdELENBQUMsRUFBRUYsV0FBVyxDQUFDO0FBQ25CO0FBQ0EsU0FBU0gseUJBQXlCQSxDQUFDTyxHQUFHLEVBQUVKLFdBQVcsRUFBRTtFQUNqRCxJQUFJLENBQUNBLFdBQVcsSUFBSUksR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsRUFBRTtJQUN2QyxPQUFPRCxHQUFHO0VBQ2Q7RUFDQSxJQUFJQSxHQUFHLEtBQUssSUFBSSxJQUFJLE9BQU9BLEdBQUcsS0FBSyxRQUFRLElBQUksT0FBT0EsR0FBRyxLQUFLLFVBQVUsRUFBRTtJQUN0RSxPQUFPO01BQ0hFLE9BQU8sRUFBRUY7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c0JBQXNCLENBQUNoQixHQUFHLENBQUM7TUFDL0I7SUFDSixDQUFDLE1BQU0sRUFFTjtFQUNMLENBQUM7QUFDTCIsInNvdXJjZXMiOlsiL2hvbWUvbWF4L2Rldi9wcmlzbWEtZmFybWFjaWEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvY3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXZcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXY7XG4gICAgfVxufSk7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkge1xuICAgIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICAgIHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uKG5vZGVJbnRlcm9wKSB7XG4gICAgICAgIHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDtcbiAgICB9KShub2RlSW50ZXJvcCk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHtcbiAgICBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTtcbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICAgIH1cbiAgICB2YXIgbmV3T2JqID0ge1xuICAgICAgICBfX3Byb3RvX186IG51bGxcbiAgICB9O1xuICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuY29uc3QgZXJyb3JSZWYgPSB7XG4gICAgY3VycmVudDogbnVsbFxufTtcbi8vIFJlYWN0LmNhY2hlIGlzIGN1cnJlbnRseSBvbmx5IGF2YWlsYWJsZSBpbiBjYW5hcnkvZXhwZXJpbWVudGFsIFJlYWN0IGNoYW5uZWxzLlxuY29uc3QgY2FjaGUgPSB0eXBlb2YgX3JlYWN0LmNhY2hlID09PSAnZnVuY3Rpb24nID8gX3JlYWN0LmNhY2hlIDogKGZuKT0+Zm47XG4vLyBXaGVuIER5bmFtaWMgSU8gaXMgZW5hYmxlZCwgd2UgcmVjb3JkIHRoZXNlIGFzIGVycm9ycyBzbyB0aGF0IHRoZXlcbi8vIGFyZSBjYXB0dXJlZCBieSB0aGUgZGV2IG92ZXJsYXkgYXMgaXQncyBtb3JlIGNyaXRpY2FsIHRvIGZpeCB0aGVzZVxuLy8gd2hlbiBlbmFibGVkLlxuY29uc3QgbG9nRXJyb3JPcldhcm4gPSBwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19JTyA/IGNvbnNvbGUuZXJyb3IgOiBjb25zb2xlLndhcm47XG4vLyBXZSBkb24ndCB3YW50IHRvIGRlZHVwZSBhY3Jvc3MgcmVxdWVzdHMuXG4vLyBUaGUgZGV2ZWxvcGVyIG1pZ2h0J3ZlIGp1c3QgYXR0ZW1wdGVkIHRvIGZpeCB0aGUgd2FybmluZyBzbyB3ZSBzaG91bGQgd2FybiBhZ2FpbiBpZiBpdCBzdGlsbCBoYXBwZW5zLlxuY29uc3QgZmx1c2hDdXJyZW50RXJyb3JJZk5ldyA9IGNhY2hlKC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgLS0gY2FjaGUga2V5XG4oa2V5KT0+e1xuICAgIHRyeSB7XG4gICAgICAgIGxvZ0Vycm9yT3JXYXJuKGVycm9yUmVmLmN1cnJlbnQpO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgZXJyb3JSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KGdldE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbG9nRGVkdXBlZEVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdldE1lc3NhZ2UoLi4uYXJncyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX3N0YWNrO1xuICAgICAgICAgICAgY29uc3QgY2FsbFN0YWNrRnJhbWVzID0gKF9zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChjYWxsU3RhY2tGcmFtZXMgPT09IHVuZGVmaW5lZCB8fCBjYWxsU3RhY2tGcmFtZXMubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yT3JXYXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvcjpcbiAgICAgICAgICAgICAgICAvLyAgIGxvZ0RlZHVwZWRFcnJvclxuICAgICAgICAgICAgICAgIC8vICAgYXN5bmNBcGlCZWluZ0FjY2Vzc2VkU3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIC8vICAgPHVzZXJsYW5kIGNhbGxzaXRlPlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIGlmIHNvdXJjZW1hcHMgd2l0aCBpZ25vcmUgbGlzdHMgYXJlIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2FsbFN0YWNrRnJhbWVzWzRdO1xuICAgICAgICAgICAgICAgIGVycm9yUmVmLmN1cnJlbnQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGZsdXNoQ3VycmVudEVycm9ySWZOZXcoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yT3JXYXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWRlZHVwZWQtYnktY2FsbHNpdGUtc2VydmVyLWVycm9yLWxvZ2dlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiIsIl9yZWFjdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsIl9fcHJvdG9fXyIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJlcnJvclJlZiIsImN1cnJlbnQiLCJmbiIsImxvZ0Vycm9yT3JXYXJuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9EWU5BTUlDX0lPIiwiY29uc29sZSIsImVycm9yIiwid2FybiIsImZsdXNoQ3VycmVudEVycm9ySWZOZXciLCJnZXRNZXNzYWdlIiwibG9nRGVkdXBlZEVycm9yIiwiYXJncyIsIm1lc3NhZ2UiLCJOT0RFX0VOViIsIl9zdGFjayIsImNhbGxTdGFja0ZyYW1lcyIsIkVycm9yIiwic3RhY2siLCJzcGxpdCIsInVuZGVmaW5lZCIsImxlbmd0aCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/server/request/params.browser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createRenderParamsFromClient\", ({\n  enumerable: true,\n  get: function () {\n    return createRenderParamsFromClient;\n  }\n}));\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nfunction createRenderParamsFromClient(underlyingParams) {\n  if (true) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams);\n  } else {}\n}\nconst CachedParams = new WeakMap();\nfunction makeUntrackedExoticParams(underlyingParams) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  const promise = Promise.resolve(underlyingParams);\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams);\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop);\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n        // We are accessing a property that was proxied to the promise instance\n        proxiedProperties.has(prop)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n          warnForSyncAccess(expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n    },\n    ownKeys(target) {\n      warnForEnumeration(unproxiedProperties);\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedParams.set(underlyingParams, proxiedPromise);\n  return proxiedPromise;\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : function warnForSyncAccess(expression) {\n  if (false) {}\n  console.error(`A param property was accessed directly with ${expression}. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.`);\n};\nconst warnForEnumeration =  false ? 0 : function warnForEnumeration(missingProperties) {\n  if (false) {}\n  if (missingProperties.length) {\n    const describedMissingProperties = describeListOfPropertyNames(missingProperties);\n    console.error(`params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` + `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n  } else {\n    console.error(`params are being enumerated. ` + `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n  }\n};\nfunction describeListOfPropertyNames(properties) {\n  switch (properties.length) {\n    case 0:\n      throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n    case 1:\n      return `\\`${properties[0]}\\``;\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n    default:\n      {\n        let description = '';\n        for (let i = 0; i < properties.length - 1; i++) {\n          description += `\\`${properties[i]}\\`, `;\n        }\n        description += `, and \\`${properties[properties.length - 1]}\\``;\n        return description;\n      }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGdFQUErRDtFQUMzREksVUFBVSxFQUFFLElBQUk7RUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDWixPQUFPQyw0QkFBNEI7RUFDdkM7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxRQUFRLEdBQUdDLG1CQUFPLENBQUMsMElBQXdDLENBQUM7QUFDbEUsTUFBTUMsZUFBZSxHQUFHRCxtQkFBTyxDQUFDLG9IQUFrQyxDQUFDO0FBQ25FLE1BQU1FLE1BQU0sR0FBR0YsbUJBQU8sQ0FBQyxxRkFBUyxDQUFDO0FBQ2pDLFNBQVNGLDRCQUE0QkEsQ0FBQ0ssZ0JBQWdCLEVBQUU7RUFDcEQsSUFBSUMsSUFBc0MsRUFBRTtJQUN4QyxPQUFPRyxpREFBaUQsQ0FBQ0osZ0JBQWdCLENBQUM7RUFDOUUsQ0FBQyxNQUFNLEVBRU47QUFDTDtBQUNBLE1BQU1NLFlBQVksR0FBRyxJQUFJQyxPQUFPLENBQUMsQ0FBQztBQUNsQyxTQUFTRix5QkFBeUJBLENBQUNMLGdCQUFnQixFQUFFO0VBQ2pELE1BQU1RLFlBQVksR0FBR0YsWUFBWSxDQUFDWixHQUFHLENBQUNNLGdCQUFnQixDQUFDO0VBQ3ZELElBQUlRLFlBQVksRUFBRTtJQUNkLE9BQU9BLFlBQVk7RUFDdkI7RUFDQSxNQUFNQyxPQUFPLEdBQUdDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDWCxnQkFBZ0IsQ0FBQztFQUNqRE0sWUFBWSxDQUFDTSxHQUFHLENBQUNaLGdCQUFnQixFQUFFUyxPQUFPLENBQUM7RUFDM0NwQixNQUFNLENBQUN3QixJQUFJLENBQUNiLGdCQUFnQixDQUFDLENBQUNjLE9BQU8sQ0FBRUMsSUFBSSxJQUFHO0lBQzFDLElBQUlo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QUUsSUFBRztRQUMvRCxPQUFPSyxXQUFXO01BQ3RCO0VBQ1I7QUFDSiIsInNvdXJjZXMiOlsiL2hvbWUvbWF4L2Rldi9wcmlzbWEtZmFybWFjaWEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMuYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQ7XG4gICAgfVxufSk7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdFwiKTtcbmNvbnN0IF9pbnZhcmlhbnRlcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvclwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCh1bmRlcmx5aW5nUGFyYW1zKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZFBhcmFtcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMpIHtcbiAgICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb21pc2UpO1xuICAgIE9iamVjdC5rZXlzKHVuZGVybHlpbmdQYXJhbXMpLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgIGlmIChfdXRpbHMud2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3ModW5kZXJseWluZ1BhcmFtcykge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgd2FzIHByb3hpZWQgdG8gdGhlIHByb21pc2UgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3BhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgKHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgd2FybkZvckVudW1lcmF0aW9uKHVucHJveGllZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuY29uc3Qgbm9vcCA9ICgpPT57fTtcbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiBmdW5jdGlvbiB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBBIHBhcmFtIHByb3BlcnR5IHdhcyBhY2Nlc3NlZCBkaXJlY3RseSB3aXRoICR7ZXhwcmVzc2lvbn0uIFxcYHBhcmFtc1xcYCBpcyBub3cgYSBQcm9taXNlIGFuZCBzaG91bGQgYmUgdW53cmFwcGVkIHdpdGggXFxgUmVhY3QudXNlKClcXGAgYmVmb3JlIGFjY2Vzc2luZyBwcm9wZXJ0aWVzIG9mIHRoZSB1bmRlcmx5aW5nIHBhcmFtcyBvYmplY3QuIEluIHRoaXMgdmVyc2lvbiBvZiBOZXh0LmpzIGRpcmVjdCBhY2Nlc3MgdG8gcGFyYW0gcHJvcGVydGllcyBpcyBzdGlsbCBzdXBwb3J0ZWQgdG8gZmFjaWxpdGF0ZSBtaWdyYXRpb24gYnV0IGluIGEgZnV0dXJlIHZlcnNpb24geW91IHdpbGwgYmUgcmVxdWlyZWQgdG8gdW53cmFwIFxcYHBhcmFtc1xcYCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgLmApO1xufTtcbmNvbnN0IHdhcm5Gb3JFbnVtZXJhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogZnVuY3Rpb24gd2FybkZvckVudW1lcmF0aW9uKG1pc3NpbmdQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWlzc2luZ1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaWJlZE1pc3NpbmdQcm9wZXJ0aWVzID0gZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKG1pc3NpbmdQcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgcGFyYW1zIGFyZSBiZWluZyBlbnVtZXJhdGVkIGluY29tcGxldGVseSBtaXNzaW5nIHRoZXNlIHByb3BlcnRpZXM6ICR7ZGVzY3JpYmVkTWlzc2luZ1Byb3BlcnRpZXN9LiBgICsgYFxcYHBhcmFtc1xcYCBzaG91bGQgYmUgdW53cmFwcGVkIHdpdGggXFxgUmVhY3QudXNlKClcXGAgYmVmb3JlIHVzaW5nIGl0cyB2YWx1ZS4gYCArIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHBhcmFtcyBhcmUgYmVpbmcgZW51bWVyYXRlZC4gYCArIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpIHtcbiAgICBzd2l0Y2gocHJvcGVydGllcy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgX2ludmFyaWFudGVycm9yLkludmFyaWFudEVycm9yKCdFeHBlY3RlZCBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMgdG8gYmUgY2FsbGVkIHdpdGggYSBub24tZW1wdHkgbGlzdCBvZiBzdHJpbmdzLicpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gYFxcYCR7cHJvcGVydGllc1swXX1cXGBgO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gYFxcYCR7cHJvcGVydGllc1swXX1cXGAgYW5kIFxcYCR7cHJvcGVydGllc1sxXX1cXGBgO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGBcXGAke3Byb3BlcnRpZXNbaV19XFxgLCBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgLCBhbmQgXFxgJHtwcm9wZXJ0aWVzW3Byb3BlcnRpZXMubGVuZ3RoIC0gMV19XFxgYDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbXMuYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCIsIl9yZWZsZWN0IiwicmVxdWlyZSIsIl9pbnZhcmlhbnRlcnJvciIsIl91dGlscyIsInVuZGVybHlpbmdQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyIsIkNhY2hlZFBhcmFtcyIsIldlYWtNYXAiLCJjYWNoZWRQYXJhbXMiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXQiLCJrZXlzIiwiZm9yRWFjaCIsInByb3AiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiaGFzIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwiYWRkIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInJlY2VpdmVyIiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwiZGVsZXRlIiwib3duS2V5cyIsIndhcm5Gb3JFbnVtZXJhdGlvbiIsIlJlZmxlY3QiLCJub29wIiwiX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyIsImNvbnNvbGUiLCJlcnJvciIsIm1pc3NpbmdQcm9wZXJ0aWVzIiwibGVuZ3RoIiwiZGVzY3JpYmVkTWlzc2luZ1Byb3BlcnRpZXMiLCJkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0aWVzIiwiSW52YXJpYW50RXJyb3IiLCJkZXNjcmlwdGlvbiIsImkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/params.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/server/request/params.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createParamsFromClient: function () {\n    return createParamsFromClient;\n  },\n  createPrerenderParamsForClientSegment: function () {\n    return createPrerenderParamsForClientSegment;\n  },\n  createServerParamsForMetadata: function () {\n    return createServerParamsForMetadata;\n  },\n  createServerParamsForRoute: function () {\n    return createServerParamsForRoute;\n  },\n  createServerParamsForServerSegment: function () {\n    return createServerParamsForServerSegment;\n  }\n});\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-unit-async-storage.external.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(app-pages-browser)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _creatededupedbycallsiteservererrorlogger = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ \"(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\");\nfunction createParamsFromClient(underlyingParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderParams(underlyingParams, workStore);\n}\nconst createServerParamsForMetadata = createServerParamsForServerSegment;\nfunction createServerParamsForRoute(underlyingParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderParams(underlyingParams, workStore);\n}\nfunction createServerParamsForServerSegment(underlyingParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderParams(underlyingParams, workStore);\n}\nfunction createPrerenderParamsForClientSegment(underlyingParams, workStore) {\n  const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams;\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams);\n}\nfunction createPrerenderParams(underlyingParams, workStore, prerenderStore) {\n  const fallbackParams = workStore.fallbackRouteParams;\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false;\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true;\n        break;\n      }\n    }\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      if (prerenderStore.type === 'prerender') {\n        // We are in a dynamicIO (PPR or otherwise) prerender\n        return makeAbortingExoticParams(underlyingParams, workStore.route, prerenderStore);\n      }\n      // remaining cases are prender-ppr and prerender-legacy\n      // We aren't in a dynamicIO prerender but we do have fallback params at this\n      // level so we need to make an erroring exotic params object which will postpone\n      // if you access the fallback params\n      return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n    }\n  }\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams);\n}\nfunction createRenderParams(underlyingParams, workStore) {\n  if ( true && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, workStore);\n  } else {\n    return makeUntrackedExoticParams(underlyingParams);\n  }\n}\nconst CachedParams = new WeakMap();\nfunction makeAbortingExoticParams(underlyingParams, route, prerenderStore) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n          const error = createParamsAccessError(route, expression);\n          (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true\n          });\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  });\n  return promise;\n}\nfunction makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  const augmentedUnderlying = {\n    ...underlyingParams\n  };\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying);\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n          },\n          enumerable: true\n        });\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true\n            });\n          },\n          enumerable: true,\n          configurable: true\n        });\n      } else {\n        promise[prop] = underlyingParams[prop];\n      }\n    }\n  });\n  return promise;\n}\nfunction makeUntrackedExoticParams(underlyingParams) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams);\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise(resolve => (0, _scheduler.scheduleImmediate)(() => resolve(underlyingParams)));\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop);\n    } else {\n      proxiedProperties.add(prop);\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n        // We are accessing a property that was proxied to the promise instance\n        proxiedProperties.has(prop)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n          syncIODev(store.route, expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression';\n      syncIODev(store.route, expression, unproxiedProperties);\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedParams.set(underlyingParams, proxiedPromise);\n  return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore;\n    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties);\n  } else {\n    warnForSyncAccess(route, expression);\n  }\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);\nconst warnForIncompleteEnumeration =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);\nfunction createParamsAccessError(route, expression) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction describeListOfPropertyNames(properties) {\n  switch (properties.length) {\n    case 0:\n      throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n    case 1:\n      return `\\`${properties[0]}\\``;\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n    default:\n      {\n        let description = '';\n        for (let i = 0; i < properties.length - 1; i++) {\n          description += `\\`${properties[i]}\\`, `;\n        }\n        description += `, and \\`${properties[properties.length - 1]}\\``;\n        return description;\n      }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGLENBQUMsS0FBS0MsQ0FNTCxDQUFDO0FBQ0YsU0FBU00sT0FBT0EsQ0FBQ0MsTUFBTSxFQUFFQyxHQUFHLEVBQUU7RUFDMUIsS0FBSSxJQUFJQyxJQUFJLElBQUlELEdBQUcsRUFBQ1osTUFBTSxDQUFDQyxjQUFjLENBQUNVLE1BQU0sRUFBRUUsSUFBSSxFQUFFO0lBQ3BEQyxVQUFVLEVBQUUsSUFBSTtJQUNoQkMsR0FBRyxFQUFFSCxHQUFHLENBQUNDLElBQUk7RUFDakIsQ0FBQyxDQUFDO0FBQ047QUFDQUgsT0FBTyxDQUFDUixPQUFPLEVBQUU7RUFDYkcsc0JBQXNCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQy9CLE9BQU9BLHNCQUFzQjtFQUNqQyxDQUFDO0VBQ0RDLHFDQUFxQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUM5QyxPQUFPQSxxQ0FBcUM7RUFDaEQsQ0FBQztFQUNEQyw2QkFBNkIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDdEMsT0FBT0EsNkJBQTZCO0VBQ3hDLENBQUM7RUFDREMsMEJBQTBCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ25DLE9BQU9BLDBCQUEwQjtFQUNyQyxDQUFDO0VBQ0RDLGtDQUFrQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUMzQyxPQUFPQSxrQ0FBa0M7RUFDN0M7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNTyxRQUFRLEdBQUdDLG1CQUFPLENBQUMsMElBQXdDLENBQUM7QUFDbEUsTUFBTUMsaUJBQWlCLEdBQUdELG1CQUFPLENBQUMsNEhBQWlDLENBQUM7QUFDcEUsTUFBTUUsNkJBQTZCLEdBQUdGLG1CQUFPLENBQUMsK0lBQWdELENBQUM7QUFDL0YsTUFBTUcsZUFBZSxH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QUFDO0FBQzVXO0FBQ0EsU0FBU2EsMkJBQTJCQSxDQUFDQyxVQUFVLEVBQUU7RUFDN0MsUUFBT0EsVUFBVSxDQUFDVixNQUFNO0lBQ3BCLEtBQUssQ0FBQztNQUNGLE1BQU0sSUFBSXhFLGVBQWUsQ0FBQ21GLGNBQWMsQ0FBQyxxRkFBcUYsQ0FBQztJQUNuSSxLQUFLLENBQUM7TUFDRixPQUFRLEtBQUlELFVBQVUsQ0FBQyxDQUFDLENBQUUsSUFBRztJQUNqQyxLQUFLLENBQUM7TUFDRixPQUFRLEtBQUlBLFVBQVUsQ0FBQyxDQUFDLENBQUUsWUFBV0EsVUFBVSxDQUFDLENBQUMsQ0FBRSxJQUFHO0lBQzFEO01BQ0k7UUFDSSxJQUFJRSxXQUFXLEdBQUcsRUFBRTtRQUNwQixLQUFJLElBQUlDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0gsVUFBVSxDQUFDVixNQUFNLEdBQUcsQ0FBQyxFQUFFYSxDQUFDLEVBQUUsRUFBQztVQUMxQ0QsV0FBVyxJQUFLLEtBQUlGLFVBQVUsQ0FBQ0csQ0FBQyxDQUFFLE1BQUs7UUFDM0M7UUFDQUQsV0FBVyxJQUFLLFdBQVVGLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDVixNQUFNLEdBQUcsQ0FBQyxDQUFFLElBQUc7UUFDL0QsT0FBT1ksV0FBVztNQUN0QjtFQUNSO0FBQ0oiLCJzb3VyY2VzIjpbIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlUGFyYW1zRnJvbUNsaWVudDogbnVsbCxcbiAgICBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50OiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclJvdXRlOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUGFyYW1zRnJvbUNsaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUHJlcmVuZGVyUGFyYW1zRm9yQ2xpZW50U2VnbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGE7XG4gICAgfSxcbiAgICBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZTtcbiAgICB9LFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUGFyYW1zRm9yU2VydmVyU2VnbWVudDtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWZsZWN0ID0gcmVxdWlyZShcIi4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0XCIpO1xuY29uc3QgX2R5bmFtaWNyZW5kZXJpbmcgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZ1wiKTtcbmNvbnN0IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfaW52YXJpYW50ZXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3JcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5ndXRpbHMgPSByZXF1aXJlKFwiLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHNcIik7XG5jb25zdCBfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlciA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyXCIpO1xuY29uc3QgX3NjaGVkdWxlciA9IHJlcXVpcmUoXCIuLi8uLi9saWIvc2NoZWR1bGVyXCIpO1xuZnVuY3Rpb24gY3JlYXRlUGFyYW1zRnJvbUNsaWVudCh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpIHtcbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgICBzd2l0Y2god29ya1VuaXRTdG9yZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpO1xufVxuY29uc3QgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEgPSBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JTZXJ2ZXJTZWdtZW50O1xuZnVuY3Rpb24gY3JlYXRlU2VydmVyUGFyYW1zRm9yUm91dGUodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclBhcmFtc0ZvckNsaWVudFNlZ21lbnQodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIHVuZGVybHlpbmdQYXJhbXMpe1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmFtcyBvYmplY3QgaGFzIG9uZSBvZiBtb3JlIGZhbGxiYWNrIHBhcmFtcyBzbyB3ZSBuZWVkIHRvIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhd2FpdGluZyBvZiB0aGlzIHBhcmFtcyBvYmplY3QgXCJkeW5hbWljXCIuIFNpbmNlIHdlIGFyZSBpbiBkeW5hbWljSU8gbW9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBlbmNvZGUgdGhpcyBhcyBhIHByb21pc2UgdGhhdCBuZXZlciByZXNvbHZlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgcGFyYW1zYCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgZG9lcyBub3QgYWJvcnQuIFdlIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aG91dFxuICAgIC8vIGFueSB0cmFja2luZyBiZWNhdXNlIHdlJ3JlIGp1c3QgdHJhbnNwb3J0aW5nIGEgdmFsdWUgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50IHdoZXJlIHRoZSB0cmFja2luZ1xuICAgIC8vIHdpbGwgYmUgYXBwbGllZC5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgIGlmIChmYWxsYmFja1BhcmFtcykge1xuICAgICAgICBsZXQgaGFzU29tZUZhbGxiYWNrUGFyYW1zID0gZmFsc2U7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gdW5kZXJseWluZ1BhcmFtcyl7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBoYXNTb21lRmFsbGJhY2tQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTb21lRmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHBhcmFtcyBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZHluYW1pYyBiZWNhdXNlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGZhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQWJvcnRpbmdFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLnJvdXRlLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1haW5pbmcgY2FzZXMgYXJlIHByZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgaW4gYSBkeW5hbWljSU8gcHJlcmVuZGVyIGJ1dCB3ZSBkbyBoYXZlIGZhbGxiYWNrIHBhcmFtcyBhdCB0aGlzXG4gICAgICAgICAgICAvLyBsZXZlbCBzbyB3ZSBuZWVkIHRvIG1ha2UgYW4gZXJyb3JpbmcgZXhvdGljIHBhcmFtcyBvYmplY3Qgd2hpY2ggd2lsbCBwb3N0cG9uZVxuICAgICAgICAgICAgLy8gaWYgeW91IGFjY2VzcyB0aGUgZmFsbGJhY2sgcGFyYW1zXG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yaW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkb24ndCBoYXZlIGFueSBmYWxsYmFjayBwYXJhbXMgc28gd2UgaGF2ZSBhbiBlbnRpcmVseSBzdGF0aWMgc2FmZSBwYXJhbXMgb2JqZWN0XG4gICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3ModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWRQYXJhbXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWFrZUFib3J0aW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHJvdXRlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgcGFyYW1zYCcpO1xuICAgIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjcmVhdGVQYXJhbXNBY2Nlc3NFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUVycm9yaW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IGF1Z21lbnRlZFVuZGVybHlpbmcgPSB7XG4gICAgICAgIC4uLnVuZGVybHlpbmdQYXJhbXNcbiAgICB9O1xuICAgIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAgIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAgIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYXVnbWVudGVkVW5kZXJseWluZyk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXVnbWVudGVkVW5kZXJseWluZywgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3BhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gbW9zdCBkeW5hbWljIEFQSXMgd2UgYWxzbyB0aHJvdyBpZiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaG93ZXZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBhcmFtcyBpcyBvbmx5IGR5bmFtaWMgd2hlbiB3ZSdyZSBnZW5lcmF0aW5nIGEgZmFsbGJhY2sgc2hlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBldmVuIHdoZW4gYGR5bmFtaWMgPSBcImVycm9yXCJgIHdlIHN0aWxsIHN1cHBvcnQgZ2VuZXJhdGluZyBkeW5hbWljXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayBzaGVsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgY29tbWVudCB3aGVuIGR5bmFtaWNJTyBpcyB0aGUgZGVmYXVsdCBzaW5jZSB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBubyBgZHluYW1pYyA9IFwiZXJyb3JcImBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIG1vc3QgZHluYW1pYyBBUElzIHdlIGFsc28gdGhyb3cgaWYgYGR5bmFtaWMgPSBcImVycm9yXCJgIGhvd2V2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwYXJhbXMgaXMgb25seSBkeW5hbWljIHdoZW4gd2UncmUgZ2VuZXJhdGluZyBhIGZhbGxiYWNrIHNoZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZXZlbiB3aGVuIGBkeW5hbWljID0gXCJlcnJvclwiYCB3ZSBzdGlsbCBzdXBwb3J0IGdlbmVyYXRpbmcgZHluYW1pY1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgc2hlbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGNvbW1lbnQgd2hlbiBkeW5hbWljSU8gaXMgdGhlIGRlZmF1bHQgc2luY2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgbm8gYGR5bmFtaWMgPSBcImVycm9yXCJgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0IChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXJhbXM7XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAgIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAgIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdQYXJhbXMsIHN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXJhbXM7XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAgIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAgIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PigwLCBfc2NoZWR1bGVyLnNjaGVkdWxlSW1tZWRpYXRlKSgoKT0+cmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKSkpO1xuICAgIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgICAgICAgdW5wcm94aWVkUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgcHJvbWlzZVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICgvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCB3YXMgcHJveGllZCB0byB0aGUgcHJvbWlzZSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKSgncGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0ICh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYC4uLnBhcmFtc2Agb3Igc2ltaWxhciBleHByZXNzaW9uJztcbiAgICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgdW5wcm94aWVkUHJvcGVydGllcyk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDYWNoZWRQYXJhbXMuc2V0KHVuZGVybHlpbmdQYXJhbXMsIHByb3hpZWRQcm9taXNlKTtcbiAgICByZXR1cm4gcHJveGllZFByb21pc2U7XG59XG5mdW5jdGlvbiBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24sIG1pc3NpbmdQcm9wZXJ0aWVzKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUgJiYgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCcgJiYgd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJQaGFzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYgd2UgbmVlZCB0byBhZHZhbmNlIG91dCBvZiB0aGVcbiAgICAgICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgICAgICBjb25zdCByZXF1ZXN0U3RvcmUgPSB3b3JrVW5pdFN0b3JlO1xuICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYpKHJlcXVlc3RTdG9yZSk7XG4gICAgfVxuICAgIC8vIEluIGFsbCBjYXNlcyB3ZSB3YXJuIG5vcm1hbGx5XG4gICAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzICYmIG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uKTtcbiAgICB9XG59XG5jb25zdCBub29wID0gKCk9Pnt9O1xuY29uc3Qgd2FybkZvclN5bmNBY2Nlc3MgPSBwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTID8gbm9vcCA6ICgwLCBfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlci5jcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KShjcmVhdGVQYXJhbXNBY2Nlc3NFcnJvcik7XG5jb25zdCB3YXJuRm9ySW5jb21wbGV0ZUVudW1lcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiAoMCwgX2NyZWF0ZWRlZHVwZWRieWNhbGxzaXRlc2VydmVyZXJyb3Jsb2dnZXIuY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldikoY3JlYXRlSW5jb21wbGV0ZUVudW1lcmF0aW9uRXJyb3IpO1xuZnVuY3Rpb24gY3JlYXRlUGFyYW1zQWNjZXNzRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICc7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICsgYFxcYHBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcykge1xuICAgIGNvbnN0IHByZWZpeCA9IHJvdXRlID8gYFJvdXRlIFwiJHtyb3V0ZX1cIiBgIDogJ1RoaXMgcm91dGUgJztcbiAgICByZXR1cm4gbmV3IEVycm9yKGAke3ByZWZpeH11c2VkICR7ZXhwcmVzc2lvbn0uIGAgKyBgXFxgcGFyYW1zXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgcHJvcGVydGllcy4gYCArIGBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgd2VyZSBub3QgYXZhaWxhYmxlIHRocm91Z2ggZW51bWVyYXRpb24gYCArIGBiZWNhdXNlIHRoZXkgY29uZmxpY3Qgd2l0aCBidWlsdGluIHByb3BlcnR5IG5hbWVzOiBgICsgYCR7ZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKG1pc3NpbmdQcm9wZXJ0aWVzKX0uIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKSB7XG4gICAgc3dpdGNoKHByb3BlcnRpZXMubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhyb3cgbmV3IF9pbnZhcmlhbnRlcnJvci5JbnZhcmlhbnRFcnJvcignRXhwZWN0ZWQgZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIHRvIGJlIGNhbGxlZCB3aXRoIGEgbm9uLWVtcHR5IGxpc3Qgb2Ygc3RyaW5ncy4nKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgYDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgIGFuZCBcXGAke3Byb3BlcnRpZXNbMV19XFxgYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgXFxgJHtwcm9wZXJ0aWVzW2ldfVxcYCwgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCwgYW5kIFxcYCR7cHJvcGVydGllc1twcm9wZXJ0aWVzLmxlbmd0aCAtIDFdfVxcYGA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW1zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImNyZWF0ZVBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50IiwiY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEiLCJjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZSIsImNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcmVmbGVjdCIsInJlcXVpcmUiLCJfZHluYW1pY3JlbmRlcmluZyIsIl93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsIiwiX2ludmFyaWFudGVycm9yIiwiX3V0aWxzIiwiX2R5bmFtaWNyZW5kZXJpbmd1dGlscyIsIl9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyIiwiX3NjaGVkdWxlciIsInVuZGVybHlpbmdQYXJhbXMiLCJ3b3JrU3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsInR5cGUiLCJjcmVhdGVQcmVyZW5kZXJQYXJhbXMiLCJjcmVhdGVSZW5kZXJQYXJhbXMiLCJwcmVyZW5kZXJTdG9yZSIsImZhbGxiYWNrUGFyYW1zIiwiZmFsbGJhY2tSb3V0ZVBhcmFtcyIsImtleSIsImhhcyIsIm1ha2VIYW5naW5nUHJvbWlzZSIsInJlbmRlclNpZ25hbCIsIlByb21pc2UiLCJyZXNvbHZlIiwiaGFzU29tZUZhbGxiYWNrUGFyYW1zIiwibWFrZUFib3J0aW5nRXhvdGljUGFyYW1zIiwicm91dGUiLCJtYWtlRXJyb3JpbmdFeG90aWNQYXJhbXMiLCJtYWtlVW50cmFja2VkRXhvdGljUGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzIiwiQ2FjaGVkUGFyYW1zIiwiV2Vha01hcCIsImNhY2hlZFBhcmFtcyIsInByb21pc2UiLCJzZXQiLCJrZXlzIiwiZm9yRWFjaCIsInByb3AiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJlcnJvciIsImNyZWF0ZVBhcmFtc0FjY2Vzc0Vycm9yIiwiYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyIsIm5ld1ZhbHVlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJhdWdtZW50ZWRVbmRlcmx5aW5nIiwicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJkeW5hbWljVHJhY2tpbmciLCJ0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbiIsInN0b3JlIiwic2NoZWR1bGVJbW1lZGlhdGUiLCJwcm94aWVkUHJvcGVydGllcyIsIlNldCIsInVucHJveGllZFByb3BlcnRpZXMiLCJwdXNoIiwiYWRkIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInJlY2VpdmVyIiwic3luY0lPRGV2IiwiUmVmbGVjdEFkYXB0ZXIiLCJkZWxldGUiLCJvd25LZXlzIiwiUmVmbGVjdCIsIm1pc3NpbmdQcm9wZXJ0aWVzIiwicHJlcmVuZGVyUGhhc2UiLCJyZXF1ZXN0U3RvcmUiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImxlbmd0aCIsIndhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24iLCJ3YXJuRm9yU3luY0FjY2VzcyIsIm5vb3AiLCJfX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTIiwiY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiIsImNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yIiwicHJlZml4IiwiRXJyb3IiLCJkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0aWVzIiwiSW52YXJpYW50RXJyb3IiLCJkZXNjcmlwdGlvbiIsImkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/server/request/search-params.browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createRenderSearchParamsFromClient\", ({\n  enumerable: true,\n  get: function () {\n    return createRenderSearchParamsFromClient;\n  }\n}));\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nfunction createRenderSearchParamsFromClient(underlyingSearchParams) {\n  if (true) {\n    return makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams);\n  } else {}\n}\nconst CachedSearchParams = new WeakMap();\nfunction makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  const promise = Promise.resolve(underlyingSearchParams);\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop);\n    } else {\n      proxiedProperties.add(prop);\n      promise[prop] = underlyingSearchParams[prop];\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n          warnForSyncAccess(expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n          warnForSyncAccess(expression);\n        }\n      }\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      warnForSyncSpread();\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n  return proxiedPromise;\n}\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams);\n  CachedSearchParams.set(underlyingSearchParams, promise);\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      promise[prop] = underlyingSearchParams[prop];\n    }\n  });\n  return promise;\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : function warnForSyncAccess(expression) {\n  if (false) {}\n  console.error(`A searchParam property was accessed directly with ${expression}. ` + `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n};\nconst warnForSyncSpread =  false ? 0 : function warnForSyncSpread() {\n  if (false) {}\n  console.error(`The keys of \\`searchParams\\` were accessed directly. ` + `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxzRUFBcUU7RUFDakVJLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ1osT0FBT0Msa0NBQWtDO0VBQzdDO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsUUFBUSxHQUFHQyxtQkFBTyxDQUFDLDBJQUF3QyxDQUFDO0FBQ2xFLE1BQU1DLE1BQU0sR0FBR0QsbUJBQU8sQ0FBQyxxRkFBUyxDQUFDO0FBQ2pDLFNBQVNGLGtDQUFrQ0EsQ0FBQ0ksc0JBQXNCLEVBQUU7RUFDaEUsSUFBSUMsSUFBc0MsRUFBRTtJQUN4QyxPQUFPRyw4Q0FBOEMsQ0FBQ0osc0JBQXNCLENBQUM7RUFDakYsQ0FBQyxNQUFNLEVBRU47QUFDTDtBQUNBLE1BQU1NLGtCQUFrQixHQUFHLElBQUlDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hDLFNBQVNILDhDQUE4Q0EsQ0FBQ0osc0JBQXNCLEVBQUU7RUFDNUUsTUFBTVEsa0JBQWtCLEdBQUdGLGtCQUFrQixDQUFDWCxHQUFHLENBQUNLLHNCQUFzQixDQUFDO0VBQ3pFLElBQUlRLGtCQUFrQixFQUFFO0lBQ3BCLE9BQU9BLGtCQUFrQjtFQUM3QjtFQUNBLE1BQU1DLGlCQUFpQixHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQ25DLE1BQU1DLG1CQUFtQixHQUFHLEVBQUU7RUFDOUIsTUFBTUMsT0FBTyxHQUFHQyxPQUFPLENBQUNDLE9BQU8sQ0FBQ2Qsc0JBQXNCLENBQUM7RUFDdkRWLE1BQU0sQ0FBQ3lCLElBQUksQ0FBQ2Ysc0JBQXNCLENBQUMsQ0FBQ2dCLE9BQU8sQ0FBRUMsSUFBSSxJQUFHO0lBQ2hELElBQUlsQixNQUFN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QzdCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsTUFBTUksT0FBTyxHQUFHQyxPQUFPLENBQUNDLE9BQU8sQ0FBQ2Qsc0JBQXNCLENBQUM7RUFDdkRNLGtCQUFrQixDQUFDeUIsR0FBRyxDQUFDL0Isc0JBQXNCLEVBQUVZLE9BQU8sQ0FBQztFQUN2RHRCLE1BQU0sQ0FBQ3lCLElBQUksQ0FBQ2Ysc0JBQXNCLENBQUMsQ0FBQ2dCLE9BQU8sQ0FBRUMsSUFBSSxJQUFHO0lBQ2hELElBQUlsQixNQUFNLENBQUNtQixtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixJQUFJLENBQUMsRUFBRTtNQUMxQztNQUNBO0lBQUEsQ0FDQyxNQUFNO01BQ0hMLE9BQU8sQ0FBQ0ssSUFBSSxDQUFDLEdBQUdqQixzQkFBc0IsQ0FBQ2lCLElBQUksQ0FBQztJQUNoRDtFQUNKLENBQUMsQ0FBQztFQUNGLE9BQU9MLE9BQU87QUFDbEI7QUFDQSxNQUFNd0IsSUFBSSxHQUFHQSxDQUFBLEtBQUksQ0FBQyxDQUFDO0FBQ25CLE1BQU1QLGlCQUFpQixHQUFHNUIsTUFBb0QsR0FBR21DLENBQUksR0FBRyxTQUFTUCxpQkFBaUJBLENBQUNGLFVBQVUsRUFBRTtFQUMzSCxJQUFJMUIsS0FBb0QsRUFBRSxFQUV6RDtFQUNEcUMsT0FBTyxDQUFDQyxLQUFLLENBQUUscURBQW9EWixVQUFXLElBQUcsR0FBSSw2RkFBNEYsR0FBSSxnRUFBK0QsQ0FBQztBQUN6UCxDQUFDO0FBQ0QsTUFBTVEsaUJBQWlCLEdBQUdsQyxNQUFvRCxHQUFHbUMsQ0FBSSxHQUFHLFNBQVNELGlCQUFpQkEsQ0FBQSxFQUFHO0VBQ2pILElBQUlsQyxLQUFvRCxFQUFFLEVBRXpEO0VBQ0RxQyxPQUFPLENBQUNDLEtBQUssQ0FBRSx1REFBc0QsR0FBSSw2RkFBNEYsR0FBSSxnRUFBK0QsQ0FBQztBQUM3TyxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMuYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQ7XG4gICAgfVxufSk7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIH1cbn1cbmNvbnN0IENhY2hlZFNlYXJjaFBhcmFtcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgcHJveGllZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5wcm94aWVkUHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJiAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8IC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCAodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApICYmIChwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkgfHwgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBvbiB0aGUgcHJvbWlzZSBub3JcbiAgICAgICAgICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBzZWFyY2hQYXJhbXMuXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSkoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5cyAodGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuRm9yU3luY1NwcmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHNlYXJjaFBhcmFtc1xuICAgIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAgIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm9taXNlKTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5jb25zdCBub29wID0gKCk9Pnt9O1xuY29uc3Qgd2FybkZvclN5bmNBY2Nlc3MgPSBwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTID8gbm9vcCA6IGZ1bmN0aW9uIHdhcm5Gb3JTeW5jQWNjZXNzKGV4cHJlc3Npb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoYEEgc2VhcmNoUGFyYW0gcHJvcGVydHkgd2FzIGFjY2Vzc2VkIGRpcmVjdGx5IHdpdGggJHtleHByZXNzaW9ufS4gYCArIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSBhY2Nlc3NpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbn07XG5jb25zdCB3YXJuRm9yU3luY1NwcmVhZCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogZnVuY3Rpb24gd2FybkZvclN5bmNTcHJlYWQoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBUaGUga2V5cyBvZiBcXGBzZWFyY2hQYXJhbXNcXGAgd2VyZSBhY2Nlc3NlZCBkaXJlY3RseS4gYCArIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSBhY2Nlc3NpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaC1wYXJhbXMuYnJvd3Nlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsIl9yZWZsZWN0IiwicmVxdWlyZSIsIl91dGlscyIsInVuZGVybHlpbmdTZWFyY2hQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtYWtlVW50cmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyIsIkNhY2hlZFNlYXJjaFBhcmFtcyIsIldlYWtNYXAiLCJjYWNoZWRTZWFyY2hQYXJhbXMiLCJwcm94aWVkUHJvcGVydGllcyIsIlNldCIsInVucHJveGllZFByb3BlcnRpZXMiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJrZXlzIiwiZm9yRWFjaCIsInByb3AiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiaGFzIiwicHVzaCIsImFkZCIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJleHByZXNzaW9uIiwiZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyIsIndhcm5Gb3JTeW5jQWNjZXNzIiwiUmVmbGVjdEFkYXB0ZXIiLCJzZXQiLCJkZWxldGUiLCJkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkiLCJvd25LZXlzIiwid2FybkZvclN5bmNTcHJlYWQiLCJub29wIiwiX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyIsImNvbnNvbGUiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/server/request/search-params.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createPrerenderSearchParamsForClientPage: function () {\n    return createPrerenderSearchParamsForClientPage;\n  },\n  createSearchParamsFromClient: function () {\n    return createSearchParamsFromClient;\n  },\n  createServerSearchParamsForMetadata: function () {\n    return createServerSearchParamsForMetadata;\n  },\n  createServerSearchParamsForServerPage: function () {\n    return createServerSearchParamsForServerPage;\n  }\n});\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-unit-async-storage.external.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(app-pages-browser)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _creatededupedbycallsiteservererrorlogger = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ \"(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\");\nfunction createSearchParamsFromClient(underlyingSearchParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore);\n}\nconst createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;\nfunction createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore);\n}\nfunction createPrerenderSearchParamsForClientPage(workStore) {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({});\n  }\n  const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    // dynamicIO Prerender\n    // We're prerendering in a mode that aborts (dynamicIO) and should stall\n    // the promise to ensure the RSC side is considered dynamic\n    return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n  }\n  // We're prerendering in a mode that does not aborts. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve({});\n}\nfunction createPrerenderSearchParams(workStore, prerenderStore) {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({});\n  }\n  if (prerenderStore.type === 'prerender') {\n    // We are in a dynamicIO (PPR or otherwise) prerender\n    return makeAbortingExoticSearchParams(workStore.route, prerenderStore);\n  }\n  // The remaining cases are prerender-ppr and prerender-legacy\n  // We are in a legacy static generation and need to interrupt the prerender\n  // when search params are accessed.\n  return makeErroringExoticSearchParams(workStore, prerenderStore);\n}\nfunction createRenderSearchParams(underlyingSearchParams, workStore) {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({});\n  } else {\n    if ( true && !workStore.isPrefetchRequest) {\n      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\n    } else {\n      return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);\n    }\n  }\n}\nconst CachedSearchParams = new WeakMap();\nfunction makeAbortingExoticSearchParams(route, prerenderStore) {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return _reflect.ReflectAdapter.get(target, prop, receiver);\n      }\n      switch (prop) {\n        case 'then':\n          {\n            const expression = '`await searchParams`, `searchParams.then`, or similar';\n            (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        case 'status':\n          {\n            const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n            (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        // Object prototype\n        case 'hasOwnProperty':\n        case 'isPrototypeOf':\n        case 'propertyIsEnumerable':\n        case 'toString':\n        case 'valueOf':\n        case 'toLocaleString':\n        // Promise prototype\n        // fallthrough\n        case 'catch':\n        case 'finally':\n        // Common tested properties\n        // fallthrough\n        case 'toJSON':\n        case '$$typeof':\n        case '__esModule':\n          {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        default:\n          {\n            if (typeof prop === 'string') {\n              const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n              const error = createSearchAccessError(route, expression);\n              (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n        const error = createSearchAccessError(route, expression);\n        (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n      }\n      return _reflect.ReflectAdapter.has(target, prop);\n    },\n    ownKeys() {\n      const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n      const error = createSearchAccessError(route, expression);\n      (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n    }\n  });\n  CachedSearchParams.set(prerenderStore, proxiedPromise);\n  return proxiedPromise;\n}\nfunction makeErroringExoticSearchParams(workStore, prerenderStore) {\n  const cachedSearchParams = CachedSearchParams.get(workStore);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const underlyingSearchParams = {};\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams);\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return _reflect.ReflectAdapter.get(target, prop, receiver);\n      }\n      switch (prop) {\n        // Object prototype\n        case 'hasOwnProperty':\n        case 'isPrototypeOf':\n        case 'propertyIsEnumerable':\n        case 'toString':\n        case 'valueOf':\n        case 'toLocaleString':\n        // Promise prototype\n        // fallthrough\n        case 'catch':\n        case 'finally':\n        // Common tested properties\n        // fallthrough\n        case 'toJSON':\n        case '$$typeof':\n        case '__esModule':\n          {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        case 'then':\n          {\n            const expression = '`await searchParams`, `searchParams.then`, or similar';\n            if (workStore.dynamicShouldError) {\n              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n            return;\n          }\n        case 'status':\n          {\n            const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n            if (workStore.dynamicShouldError) {\n              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n            return;\n          }\n        default:\n          {\n            if (typeof prop === 'string') {\n              const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n              if (workStore.dynamicShouldError) {\n                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n              } else if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n              } else {\n                // Legacy Prerender\n                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n              }\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n        if (workStore.dynamicShouldError) {\n          (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no dynamicIO)\n          (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n        } else {\n          // Legacy Prerender\n          (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n        }\n        return false;\n      }\n      return _reflect.ReflectAdapter.has(target, prop);\n    },\n    ownKeys() {\n      const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n      if (workStore.dynamicShouldError) {\n        (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n      } else if (prerenderStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n      } else {\n        // Legacy Prerender\n        (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n      }\n    }\n  });\n  CachedSearchParams.set(workStore, proxiedPromise);\n  return proxiedPromise;\n}\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams, store) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams);\n  CachedSearchParams.set(underlyingSearchParams, promise);\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n      // React Promise extension\n      // fallthrough\n      case 'status':\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule':\n        {\n          break;\n        }\n      default:\n        {\n          Object.defineProperty(promise, prop, {\n            get() {\n              const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n              (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);\n              return underlyingSearchParams[prop];\n            },\n            set(value) {\n              Object.defineProperty(promise, prop, {\n                value,\n                writable: true,\n                enumerable: true\n              });\n            },\n            enumerable: true,\n            configurable: true\n          });\n        }\n    }\n  });\n  return promise;\n}\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false;\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n          (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n        }\n        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n          (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n        }\n      }\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n        (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n      }\n      return Reflect.ownKeys(target);\n    }\n  });\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise(resolve => (0, _scheduler.scheduleImmediate)(() => resolve(underlyingSearchParams)));\n  promise.then(() => {\n    promiseInitialized = true;\n  });\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop);\n    } else {\n      proxiedProperties.add(prop);\n      Object.defineProperty(promise, prop, {\n        get() {\n          return proxiedUnderlying[prop];\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true\n          });\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && store.dynamicShouldError) {\n        const expression = '`searchParams.then`';\n        (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n      }\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n          syncIODev(store.route, expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n          syncIODev(store.route, expression);\n        }\n      }\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar';\n      syncIODev(store.route, expression, unproxiedProperties);\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n  return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties);\n  } else {\n    warnForSyncAccess(route, expression);\n  }\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore;\n    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);\n  }\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);\nconst warnForIncompleteEnumeration =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);\nfunction createSearchAccessError(route, expression) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin or well-known property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction describeListOfPropertyNames(properties) {\n  switch (properties.length) {\n    case 0:\n      throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n    case 1:\n      return `\\`${properties[0]}\\``;\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n    default:\n      {\n        let description = '';\n        for (let i = 0; i < properties.length - 1; i++) {\n          description += `\\`${properties[i]}\\`, `;\n        }\n        description += `, and \\`${properties[properties.length - 1]}\\``;\n        return description;\n      }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRixDQUFDLEtBQUtDLENBS0wsQ0FBQztBQUNGLFNBQVNLLE9BQU9BLENBQUNDLE1BQU0sRUFBRUMsR0FBRyxFQUFFO0VBQzFCLEtBQUksSUFBSUMsSUFBSSxJQUFJRCxHQUFHLEVBQUNYLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUyxNQUFNLEVBQUVFLElBQUksRUFBRTtJQUNwREMsVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRUgsR0FBRyxDQUFDQyxJQUFJO0VBQ2pCLENBQUMsQ0FBQztBQUNOO0FBQ0FILE9BQU8sQ0FBQ1AsT0FBTyxFQUFFO0VBQ2JHLHdDQUF3QyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUNqRCxPQUFPQSx3Q0FBd0M7RUFDbkQsQ0FBQztFQUNEQyw0QkFBNEIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDckMsT0FBT0EsNEJBQTRCO0VBQ3ZDLENBQUM7RUFDREMsbUNBQW1DLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQzVDLE9BQU9BLG1DQUFtQztFQUM5QyxDQUFDO0VBQ0RDLHFDQUFxQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUM5QyxPQUFPQSxxQ0FBcUM7RUFDaEQ7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNTyxRQUFRLEdBQUdDLG1CQUFPLENBQUMsMElBQXdDLENBQUM7QUFDbEUsTUFBTUMsaUJBQWlCLEdBQUdELG1CQUFPLENBQUMsNEhBQWlDLENBQUM7QUFDcEUsTUFBTUUsNkJBQTZCLEdBQUdGLG1CQUFPLENBQUMsK0lBQWdELENBQUM7QUFDL0YsTUFBTUcsZUFBZSxHQUFHSCxtQkFBTyxDQUFDLG9IQUFrQyxDQUFDO0FBQ25FLE1BQU1JLHNCQUFzQixHQUFHSixtQkFB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aUIsQ0FBRSxJQUFHLEdBQUksZ0VBQStELENBQUM7QUFDaFk7QUFDQSxTQUFTYSwyQkFBMkJBLENBQUNDLFVBQVUsRUFBRTtFQUM3QyxRQUFPQSxVQUFVLENBQUNiLE1BQU07SUFDcEIsS0FBSyxDQUFDO01BQ0YsTUFBTSxJQUFJMUUsZUFBZSxDQUFDd0YsY0FBYyxDQUFDLHFGQUFxRixDQUFDO0lBQ25JLEtBQUssQ0FBQztNQUNGLE9BQVEsS0FBSUQsVUFBVSxDQUFDLENBQUMsQ0FBRSxJQUFHO0lBQ2pDLEtBQUssQ0FBQztNQUNGLE9BQVEsS0FBSUEsVUFBVSxDQUFDLENBQUMsQ0FBRSxZQUFXQSxVQUFVLENBQUMsQ0FBQyxDQUFFLElBQUc7SUFDMUQ7TUFDSTtRQUNJLElBQUlFLFdBQVcsR0FBRyxFQUFFO1FBQ3BCLEtBQUksSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHSCxVQUFVLENBQUNiLE1BQU0sR0FBRyxDQUFDLEVBQUVnQixDQUFDLEVBQUUsRUFBQztVQUMxQ0QsV0FBVyxJQUFLLEtBQUlGLFVBQVUsQ0FBQ0csQ0FBQyxDQUFFLE1BQUs7UUFDM0M7UUFDQUQsV0FBVyxJQUFLLFdBQVVGLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDYixNQUFNLEdBQUcsQ0FBQyxDQUFFLElBQUc7UUFDL0QsT0FBT2UsV0FBVztNQUN0QjtFQUNSO0FBQ0oiLCJzb3VyY2VzIjpbIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtc0ZvckNsaWVudFBhZ2U6IG51bGwsXG4gICAgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudDogbnVsbCxcbiAgICBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YTogbnVsbCxcbiAgICBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtc0ZvckNsaWVudFBhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZTtcbiAgICB9LFxuICAgIGNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudDtcbiAgICB9LFxuICAgIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhO1xuICAgIH0sXG4gICAgY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yU2VydmVyUGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX3JlZmxlY3QgPSByZXF1aXJlKFwiLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3RcIik7XG5jb25zdCBfZHluYW1pY3JlbmRlcmluZyA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nXCIpO1xuY29uc3QgX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbFwiKTtcbmNvbnN0IF9pbnZhcmlhbnRlcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvclwiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5ndXRpbHMgPSByZXF1aXJlKFwiLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHNcIik7XG5jb25zdCBfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlciA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBfc2NoZWR1bGVyID0gcmVxdWlyZShcIi4uLy4uL2xpYi9zY2hlZHVsZXJcIik7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSkge1xuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAgIHN3aXRjaCh3b3JrVW5pdFN0b3JlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtcyh3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSk7XG59XG5jb25zdCBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YSA9IGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2U7XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSkge1xuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICAgIHN3aXRjaCh3b3JrVW5pdFN0b3JlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtcyh3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXNGb3JDbGllbnRQYWdlKHdvcmtTdG9yZSkge1xuICAgIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgICAvLyBkaWN0aW9uYXJ5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXJlbmRlclN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAocHJlcmVuZGVyU3RvcmUgJiYgcHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgLy8gZHluYW1pY0lPIFByZXJlbmRlclxuICAgICAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgYWJvcnRzIChkeW5hbWljSU8pIGFuZCBzaG91bGQgc3RhbGxcbiAgICAgICAgLy8gdGhlIHByb21pc2UgdG8gZW5zdXJlIHRoZSBSU0Mgc2lkZSBpcyBjb25zaWRlcmVkIGR5bmFtaWNcbiAgICAgICAgcmV0dXJuICgwLCBfZHluYW1pY3JlbmRlcmluZ3V0aWxzLm1ha2VIYW5naW5nUHJvbWlzZSkocHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLCAnYHNlYXJjaFBhcmFtc2AnKTtcbiAgICB9XG4gICAgLy8gV2UncmUgcHJlcmVuZGVyaW5nIGluIGEgbW9kZSB0aGF0IGRvZXMgbm90IGFib3J0cy4gV2UgcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRob3V0XG4gICAgLy8gYW55IHRyYWNraW5nIGJlY2F1c2Ugd2UncmUganVzdCB0cmFuc3BvcnRpbmcgYSB2YWx1ZSBmcm9tIHNlcnZlciB0byBjbGllbnQgd2hlcmUgdGhlIHRyYWNraW5nXG4gICAgLy8gd2lsbCBiZSBhcHBsaWVkLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgZm9yY2VTdGF0aWMgd2Ugb3ZlcnJpZGUgYWxsIG90aGVyIGxvZ2ljIGFuZCBhbHdheXMganVzdCByZXR1cm4gYW4gZW1wdHlcbiAgICAgICAgLy8gZGljdGlvbmFyeSBvYmplY3QuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgLy8gV2UgYXJlIGluIGEgZHluYW1pY0lPIChQUFIgb3Igb3RoZXJ3aXNlKSBwcmVyZW5kZXJcbiAgICAgICAgcmV0dXJuIG1ha2VBYm9ydGluZ0V4b3RpY1NlYXJjaFBhcmFtcyh3b3JrU3RvcmUucm91dGUsIHByZXJlbmRlclN0b3JlKTtcbiAgICB9XG4gICAgLy8gVGhlIHJlbWFpbmluZyBjYXNlcyBhcmUgcHJlcmVuZGVyLXBwciBhbmQgcHJlcmVuZGVyLWxlZ2FjeVxuICAgIC8vIFdlIGFyZSBpbiBhIGxlZ2FjeSBzdGF0aWMgZ2VuZXJhdGlvbiBhbmQgbmVlZCB0byBpbnRlcnJ1cHQgdGhlIHByZXJlbmRlclxuICAgIC8vIHdoZW4gc2VhcmNoIHBhcmFtcyBhcmUgYWNjZXNzZWQuXG4gICAgcmV0dXJuIG1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtcyh3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCB3b3JrU3RvcmUpIHtcbiAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgZm9yY2VTdGF0aWMgd2Ugb3ZlcnJpZGUgYWxsIG90aGVyIGxvZ2ljIGFuZCBhbHdheXMganVzdCByZXR1cm4gYW4gZW1wdHlcbiAgICAgICAgLy8gZGljdGlvbmFyeSBvYmplY3QuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhd29ya1N0b3JlLmlzUHJlZmV0Y2hSZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCB3b3JrU3RvcmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IENhY2hlZFNlYXJjaFBhcmFtcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtYWtlQWJvcnRpbmdFeG90aWNTZWFyY2hQYXJhbXMocm91dGUsIHByZXJlbmRlclN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldChwcmVyZW5kZXJTdG9yZSk7XG4gICAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgc2VhcmNoUGFyYW1zYCcpO1xuICAgIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICAgICAgZ2V0ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihwcm9taXNlLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcm9taXNlIGhhcyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5LiB3ZSBtdXN0IHJldHVybiBpdC5cbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IGl0IGlzbid0IGEgZHluYW1pYyBhY2Nlc3MgYmVjYXVzZSBpdCBjYW4gb25seSBiZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdhcyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHByb21pc2UgYW5kIHRodXMgbm90IGFuIHVuZGVybHlpbmcgc2VhcmNoUGFyYW0gdmFsdWVcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoKHByb3Ape1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RoZW4nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2Bhd2FpdCBzZWFyY2hQYXJhbXNgLCBgc2VhcmNoUGFyYW1zLnRoZW5gLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hbm5vdGF0ZUR5bmFtaWNBY2Nlc3MpKGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdGF0dXMnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2B1c2Uoc2VhcmNoUGFyYW1zKWAsIGBzZWFyY2hQYXJhbXMuc3RhdHVzYCwgb3Igc2ltaWxhcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcuYW5ub3RhdGVEeW5hbWljQWNjZXNzKShleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0IHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hhc093blByb3BlcnR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdpc1Byb3RvdHlwZU9mJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eUlzRW51bWVyYWJsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9TdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlT2YnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvTG9jYWxlU3RyaW5nJzpcbiAgICAgICAgICAgICAgICAvLyBQcm9taXNlIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnY2F0Y2gnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsbHknOlxuICAgICAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAndG9KU09OJzpcbiAgICAgICAgICAgICAgICBjYXNlICckJHR5cGVvZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnX19lc01vZHVsZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yKHJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcuYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzcykocm91dGUsIGV4cHJlc3Npb24sIGVycm9yLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBleHBlY3Qga2V5IGNoZWNraW5nIHRvIGJlIHVzZWQgZXhjZXB0IGZvciB0ZXN0aW5nIHRoZSBleGlzdGVuY2Ugb2ZcbiAgICAgICAgICAgIC8vIHNlYXJjaFBhcmFtcyBzbyB3ZSBtYWtlIGFsbCBoYXMgdGVzdHMgdHJpZ2dlciBkeW5hbWljLiB0aGlzIG1lYW5zIHRoYXQgYHByb21pc2UudGhlbmBcbiAgICAgICAgICAgIC8vIGNhbiByZXNvbHZlIHRvIHRoZSB0aGVuIGZ1bmN0aW9uIG9uIHRoZSBQcm9taXNlIHByb3RvdHlwZSBidXQgJ3RoZW4nIGluIHByb21pc2Ugd2lsbCBhc3N1bWVcbiAgICAgICAgICAgIC8vIHlvdSBhcmUgdGVzdGluZyB3aGV0aGVyIHRoZSBzZWFyY2hQYXJhbXMgaGFzIGEgJ3RoZW4nIHByb3BlcnR5LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSkoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5cyAoKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2B7Li4uc2VhcmNoUGFyYW1zfWAsIGBPYmplY3Qua2V5cyhzZWFyY2hQYXJhbXMpYCwgb3Igc2ltaWxhcic7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yKHJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQocHJlcmVuZGVyU3RvcmUsIHByb3hpZWRQcm9taXNlKTtcbiAgICByZXR1cm4gcHJveGllZFByb21pc2U7XG59XG5mdW5jdGlvbiBtYWtlRXJyb3JpbmdFeG90aWNTZWFyY2hQYXJhbXMod29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQod29ya1N0b3JlKTtcbiAgICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IHVuZGVybHlpbmdTZWFyY2hQYXJhbXMgPSB7fTtcbiAgICAvLyBGb3Igc2VhcmNoIHBhcmFtcyB3ZSBkb24ndCBjb25zdHJ1Y3QgYSBSZWFjdFByb21pc2UgYmVjYXVzZSB3ZSB3YW50IHRvIGludGVycnVwdFxuICAgIC8vIHJlbmRlcmluZyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgd2FzIG5vdCBzZXQgZnJvbSBvdXRzaWRlIGFuZCBzbyB3ZSBvbmx5IHdhbnRcbiAgICAvLyB0byBoYXZlIHByb3BlcnRpZXMgbGlrZSB2YWx1ZSBhbmQgc3RhdHVzIGlmIFJlYWN0IHNldHMgdGhlbS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICAgICAgZ2V0ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihwcm9taXNlLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcm9taXNlIGhhcyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5LiB3ZSBtdXN0IHJldHVybiBpdC5cbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IGl0IGlzbid0IGEgZHluYW1pYyBhY2Nlc3MgYmVjYXVzZSBpdCBjYW4gb25seSBiZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdhcyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHByb21pc2UgYW5kIHRodXMgbm90IGFuIHVuZGVybHlpbmcgc2VhcmNoUGFyYW0gdmFsdWVcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoKHByb3Ape1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdCBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICBjYXNlICdoYXNPd25Qcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaXNQcm90b3R5cGVPZic6XG4gICAgICAgICAgICAgICAgY2FzZSAncHJvcGVydHlJc0VudW1lcmFibGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvU3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2YWx1ZU9mJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b0xvY2FsZVN0cmluZyc6XG4gICAgICAgICAgICAgICAgLy8gUHJvbWlzZSBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhdGNoJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGx5JzpcbiAgICAgICAgICAgICAgICAvLyBDb21tb24gdGVzdGVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvSlNPTic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJCR0eXBlb2YnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ19fZXNNb2R1bGUnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RoZW4nOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2Bhd2FpdCBzZWFyY2hQYXJhbXNgLCBgc2VhcmNoUGFyYW1zLnRoZW5gLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHVzZShzZWFyY2hQYXJhbXMpYCwgYHNlYXJjaFBhcmFtcy5zdGF0dXNgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBleHBlY3Qga2V5IGNoZWNraW5nIHRvIGJlIHVzZWQgZXhjZXB0IGZvciB0ZXN0aW5nIHRoZSBleGlzdGVuY2Ugb2ZcbiAgICAgICAgICAgIC8vIHNlYXJjaFBhcmFtcyBzbyB3ZSBtYWtlIGFsbCBoYXMgdGVzdHMgdHJpZ2dlciBkeW5hbWljLiB0aGlzIG1lYW5zIHRoYXQgYHByb21pc2UudGhlbmBcbiAgICAgICAgICAgIC8vIGNhbiByZXNvbHZlIHRvIHRoZSB0aGVuIGZ1bmN0aW9uIG9uIHRoZSBQcm9taXNlIHByb3RvdHlwZSBidXQgJ3RoZW4nIGluIHByb21pc2Ugd2lsbCBhc3N1bWVcbiAgICAgICAgICAgIC8vIHlvdSBhcmUgdGVzdGluZyB3aGV0aGVyIHRoZSBzZWFyY2hQYXJhbXMgaGFzIGEgJ3RoZW4nIHByb3BlcnR5LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSkoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMudGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IpKHdvcmtTdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcucG9zdHBvbmVXaXRoVHJhY2tpbmcpKHdvcmtTdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy50aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbikoZXhwcmVzc2lvbiwgd29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5cyAoKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2B7Li4uc2VhcmNoUGFyYW1zfWAsIGBPYmplY3Qua2V5cyhzZWFyY2hQYXJhbXMpYCwgb3Igc2ltaWxhcic7XG4gICAgICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMudGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IpKHdvcmtTdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcucG9zdHBvbmVXaXRoVHJhY2tpbmcpKHdvcmtTdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy50aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbikoZXhwcmVzc2lvbiwgd29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHdvcmtTdG9yZSwgcHJveGllZFByb21pc2UpO1xuICAgIHJldHVybiBwcm94aWVkUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgc3RvcmUpIHtcbiAgICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2Ugc2VhcmNoUGFyYW1zXG4gICAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gICAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKTtcbiAgICBDYWNoZWRTZWFyY2hQYXJhbXMuc2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHByb21pc2UpO1xuICAgIE9iamVjdC5rZXlzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgIHN3aXRjaChwcm9wKXtcbiAgICAgICAgICAgIC8vIE9iamVjdCBwcm90b3R5cGVcbiAgICAgICAgICAgIGNhc2UgJ2hhc093blByb3BlcnR5JzpcbiAgICAgICAgICAgIGNhc2UgJ2lzUHJvdG90eXBlT2YnOlxuICAgICAgICAgICAgY2FzZSAncHJvcGVydHlJc0VudW1lcmFibGUnOlxuICAgICAgICAgICAgY2FzZSAndG9TdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAndmFsdWVPZic6XG4gICAgICAgICAgICBjYXNlICd0b0xvY2FsZVN0cmluZyc6XG4gICAgICAgICAgICAvLyBQcm9taXNlIHByb3RvdHlwZVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3RoZW4nOlxuICAgICAgICAgICAgY2FzZSAnY2F0Y2gnOlxuICAgICAgICAgICAgY2FzZSAnZmluYWxseSc6XG4gICAgICAgICAgICAvLyBSZWFjdCBQcm9taXNlIGV4dGVuc2lvblxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICAgICAgICAvLyBDb21tb24gdGVzdGVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICd0b0pTT04nOlxuICAgICAgICAgICAgY2FzZSAnJCR0eXBlb2YnOlxuICAgICAgICAgICAgY2FzZSAnX19lc01vZHVsZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIpKHN0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZXJseWluZ1NlYXJjaFBhcmFtc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXNXaXRoRGV2V2FybmluZ3ModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgc3RvcmUpIHtcbiAgICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgcHJveGllZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5wcm94aWVkUHJvcGVydGllcyA9IFtdO1xuICAgIC8vIFdlIGhhdmUgYW4gdW5mb3J0dW5hdGUgc2VxdWVuY2Ugb2YgZXZlbnRzIHRoYXQgcmVxdWlyZXMgdGhpcyBpbml0aWFsaXphdGlvbiBsb2dpYy4gV2Ugd2FudCB0byBpbnN0cnVtZW50IHRoZSB1bmRlcmx5aW5nXG4gICAgLy8gc2VhcmNoUGFyYW1zIG9iamVjdCB0byBkZXRlY3QgaWYgeW91IGFyZSBhY2Nlc3NpbmcgdmFsdWVzIGluIGRldi4gVGhpcyBpcyB1c2VkIGZvciB3YXJuaW5ncyBhbmQgZm9yIHRoaW5ncyBsaWtlIHRoZSBzdGF0aWMgcHJlcmVuZGVyXG4gICAgLy8gaW5kaWNhdG9yLiBIb3dldmVyIHdoZW4gd2UgcGFzcyB0aGlzIHByb3h5IHRvIG91ciBQcm9taXNlLnJlc29sdmUoKSBiZWxvdyB0aGUgVk0gY2hlY2tzIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhIHByb21pc2UgYnkgbG9va2luZ1xuICAgIC8vIGF0IHRoZSBgLnRoZW5gIHByb3BlcnR5LiBUbyBvdXIgZHluYW1pYyB0cmFja2luZyBsb2dpYyB0aGlzIGlzIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gYSBgdGhlbmAgc2VhcmNoUGFyYW0gYW5kIHNvIHdlIHdvdWxkIG5vcm1hbGx5IHRyaWdnZXJcbiAgICAvLyBkeW5hbWljIHRyYWNraW5nLiBIb3dldmVyIHdlIGtub3cgdGhhdCB0aGlzIC50aGVuIGlzIG5vdCByZWFsIGR5bmFtaWMgYWNjZXNzLCBpdCdzIGp1c3QgaG93IHRoZW5hYmxlcyByZXNvbHZlIGluIHNlcXVlbmNlLiBTbyB3ZSBpbnRyb2R1Y2VcbiAgICAvLyB0aGlzIGluaXRpYWxpemF0aW9uIGNvbmNlcHQgc28gd2Ugb21pdCB0aGUgZHluYW1pYyBjaGVjayB1bnRpbCBhZnRlciB3ZSd2ZSBjb25zdHJ1Y3RlZCBvdXIgcmVzb2x2ZWQgcHJvbWlzZS5cbiAgICBsZXQgcHJvbWlzZUluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgY29uc3QgcHJveGllZFVuZGVybHlpbmcgPSBuZXcgUHJveHkodW5kZXJseWluZ1NlYXJjaFBhcmFtcywge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgcHJvbWlzZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMudGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IpKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIpKHN0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2B7Li4uc2VhcmNoUGFyYW1zfWAsIGBPYmplY3Qua2V5cyhzZWFyY2hQYXJhbXMpYCwgb3Igc2ltaWxhcic7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2Ugc2VhcmNoUGFyYW1zXG4gICAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gICAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+KDAsIF9zY2hlZHVsZXIuc2NoZWR1bGVJbW1lZGlhdGUpKCgpPT5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpKSk7XG4gICAgcHJvbWlzZS50aGVuKCgpPT57XG4gICAgICAgIHByb21pc2VJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3hpZWRVbmRlcmx5aW5nW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0IChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAndGhlbicgJiYgc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgc2VhcmNoUGFyYW1zLnRoZW5gJztcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKShzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdXRpbHMud2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiYgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fCAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCAodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApICYmIChwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkgfHwgLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBvbiB0aGUgcHJvbWlzZSBub3JcbiAgICAgICAgICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBzZWFyY2hQYXJhbXMuXG4gICAgICAgICAgICAgICAgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSkoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgc3luY0lPRGV2KHN0b3JlLnJvdXRlLCBleHByZXNzaW9uLCB1bnByb3hpZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJveGllZFByb21pc2UpO1xuICAgIHJldHVybiBwcm94aWVkUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpIHtcbiAgICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICAgIGlmIChtaXNzaW5nUHJvcGVydGllcyAmJiBtaXNzaW5nUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24ocm91dGUsIGV4cHJlc3Npb24sIG1pc3NpbmdQcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICh3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnICYmIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWUpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgICAgIC8vIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHlcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0b3JlID0gd29ya1VuaXRTdG9yZTtcbiAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2KShyZXF1ZXN0U3RvcmUpO1xuICAgIH1cbn1cbmNvbnN0IG5vb3AgPSAoKT0+e307XG5jb25zdCB3YXJuRm9yU3luY0FjY2VzcyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogKDAsIF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyLmNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYpKGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yKTtcbmNvbnN0IHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTID8gbm9vcCA6ICgwLCBfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlci5jcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KShjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcik7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbikge1xuICAgIGNvbnN0IHByZWZpeCA9IHJvdXRlID8gYFJvdXRlIFwiJHtyb3V0ZX1cIiBgIDogJ1RoaXMgcm91dGUgJztcbiAgICByZXR1cm4gbmV3IEVycm9yKGAke3ByZWZpeH11c2VkICR7ZXhwcmVzc2lvbn0uIGAgKyBgXFxgc2VhcmNoUGFyYW1zXFxgIHNob3VsZCBiZSBhd2FpdGVkIGJlZm9yZSB1c2luZyBpdHMgcHJvcGVydGllcy4gYCArIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2ApO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5jb21wbGV0ZUVudW1lcmF0aW9uRXJyb3Iocm91dGUsIGV4cHJlc3Npb24sIG1pc3NpbmdQcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyB3ZXJlIG5vdCBhdmFpbGFibGUgdGhyb3VnaCBlbnVtZXJhdGlvbiBgICsgYGJlY2F1c2UgdGhleSBjb25mbGljdCB3aXRoIGJ1aWx0aW4gb3Igd2VsbC1rbm93biBwcm9wZXJ0eSBuYW1lczogYCArIGAke2Rlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhtaXNzaW5nUHJvcGVydGllcyl9LiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMocHJvcGVydGllcykge1xuICAgIHN3aXRjaChwcm9wZXJ0aWVzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRocm93IG5ldyBfaW52YXJpYW50ZXJyb3IuSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyB0byBiZSBjYWxsZWQgd2l0aCBhIG5vbi1lbXB0eSBsaXN0IG9mIHN0cmluZ3MuJyk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYGA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYCBhbmQgXFxgJHtwcm9wZXJ0aWVzWzFdfVxcYGA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYFxcYCR7cHJvcGVydGllc1tpXX1cXGAsIGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAsIGFuZCBcXGAke3Byb3BlcnRpZXNbcHJvcGVydGllcy5sZW5ndGggLSAxXX1cXGBgO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaC1wYXJhbXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZSIsImNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JNZXRhZGF0YSIsImNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2UiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcmVmbGVjdCIsInJlcXVpcmUiLCJfZHluYW1pY3JlbmRlcmluZyIsIl93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsIiwiX2ludmFyaWFudGVycm9yIiwiX2R5bmFtaWNyZW5kZXJpbmd1dGlscyIsIl9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyIiwiX3V0aWxzIiwiX3NjaGVkdWxlciIsInVuZGVybHlpbmdTZWFyY2hQYXJhbXMiLCJ3b3JrU3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJnZXRTdG9yZSIsInR5cGUiLCJjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMiLCJjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXMiLCJmb3JjZVN0YXRpYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicHJlcmVuZGVyU3RvcmUiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJtYWtlQWJvcnRpbmdFeG90aWNTZWFyY2hQYXJhbXMiLCJyb3V0ZSIsIm1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzUHJlZmV0Y2hSZXF1ZXN0IiwibWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyIsIm1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXMiLCJDYWNoZWRTZWFyY2hQYXJhbXMiLCJXZWFrTWFwIiwiY2FjaGVkU2VhcmNoUGFyYW1zIiwicHJvbWlzZSIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJoYXNPd24iLCJSZWZsZWN0QWRhcHRlciIsImV4cHJlc3Npb24iLCJhbm5vdGF0ZUR5bmFtaWNBY2Nlc3MiLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwiZXJyb3IiLCJjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvciIsImFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MiLCJoYXMiLCJkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkiLCJvd25LZXlzIiwic2V0IiwiZHluYW1pY1Nob3VsZEVycm9yIiwidGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsImR5bmFtaWNUcmFja2luZyIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwic3RvcmUiLCJrZXlzIiwiZm9yRWFjaCIsInRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInByb3hpZWRQcm9wZXJ0aWVzIiwiU2V0IiwidW5wcm94aWVkUHJvcGVydGllcyIsInByb21pc2VJbml0aWFsaXplZCIsInByb3hpZWRVbmRlcmx5aW5nIiwiUmVmbGVjdCIsInNjaGVkdWxlSW1tZWRpYXRlIiwidGhlbiIsIndlbGxLbm93blByb3BlcnRpZXMiLCJwdXNoIiwiYWRkIiwibmV3VmFsdWUiLCJzeW5jSU9EZXYiLCJkZWxldGUiLCJtaXNzaW5nUHJvcGVydGllcyIsImxlbmd0aCIsIndhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24iLCJ3YXJuRm9yU3luY0FjY2VzcyIsInByZXJlbmRlclBoYXNlIiwicmVxdWVzdFN0b3JlIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJub29wIiwiX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvciIsInByZWZpeCIsIkVycm9yIiwiZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIiwicHJvcGVydGllcyIsIkludmFyaWFudEVycm9yIiwiZGVzY3JpcHRpb24iLCJpIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/server/request/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  describeHasCheckingStringProperty: function () {\n    return describeHasCheckingStringProperty;\n  },\n  describeStringPropertyAccess: function () {\n    return describeStringPropertyAccess;\n  },\n  throwWithStaticGenerationBailoutError: function () {\n    return throwWithStaticGenerationBailoutError;\n  },\n  throwWithStaticGenerationBailoutErrorWithDynamicError: function () {\n    return throwWithStaticGenerationBailoutErrorWithDynamicError;\n  },\n  wellKnownProperties: function () {\n    return wellKnownProperties;\n  }\n});\nconst _staticgenerationbailout = __webpack_require__(/*! ../../client/components/static-generation-bailout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\n// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\n// even if this would have been fine too `searchParams._`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nfunction describeStringPropertyAccess(target, prop) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``;\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``;\n}\nfunction describeHasCheckingStringProperty(target, prop) {\n  const stringifiedProp = JSON.stringify(prop);\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`;\n}\nfunction throwWithStaticGenerationBailoutError(route, expression) {\n  throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n}\nfunction throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\n  throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n}\nconst wellKnownProperties = new Set(['hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toString', 'valueOf', 'toLocaleString',\n// Promise prototype\n// fallthrough\n'then', 'catch', 'finally',\n// React Promise extension\n// fallthrough\n'status',\n// React introspection\n'displayName',\n// Common tested properties\n// fallthrough\n'toJSON', '$$typeof', '__esModule']);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsQ0FBQyxLQUFLQyxDQU1MLENBQUM7QUFDRixTQUFTTSxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixLQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxFQUFDWixNQUFNLENBQUNDLGNBQWMsQ0FBQ1UsTUFBTSxFQUFFRSxJQUFJLEVBQUU7SUFDcERDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNSLE9BQU8sRUFBRTtFQUNiRyxpQ0FBaUMsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDMUMsT0FBT0EsaUNBQWlDO0VBQzVDLENBQUM7RUFDREMsNEJBQTRCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ3JDLE9BQU9BLDRCQUE0QjtFQUN2QyxDQUFDO0VBQ0RDLHFDQUFxQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUM5QyxPQUFPQSxxQ0FBcUM7RUFDaEQsQ0FBQztFQUNEQyxxREFBcUQsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDOUQsT0FBT0EscURBQXFEO0VBQ2hFLENBQUM7RUFDREMsbUJBQW1CLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQzVCLE9BQU9BLG1CQUFtQjtFQUM5QjtBQUNKLENBQUMsQ0FBQztBQUNGLE1BQU1PLHdCQUF3QixHQUFHQyxtQkFBTyxDQUFDLHNKQUFtRCxDQUFDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDakUsU0FBU1osNEJBQTRCQSxDQUFDSyxNQUFNLEVBQUVRLElBQUksRUFBRTtFQUNoRCxJQUFJRCw0QkFBNEIsQ0FBQ0UsSUFBSSxDQUFDRCxJQUFJLENBQUMsRUFBRTtJQUN6QyxPQUFRLEtBQUlSLE1BQU8sSUFBR1EsSUFBSyxJQUFHO0VBQ2xDO0VBQ0EsT0FBUSxLQUFJUixNQUFPLElBQUdVLElBQUksQ0FBQ0MsU0FBUyxDQUFDSCxJQUFJLENBQUUsS0FBSTtBQUNuRDtBQUNBLFNBQVNkLGlDQUFpQ0EsQ0FBQ00sTUFBTSxFQUFFUSxJQUFJLEVBQUU7RUFDckQsTUFBTUksZUFBZSxHQUFHRixJQUFJLENBQUNDLFNBQVMsQ0FBQ0gsSUFBSSxDQUFDO0VBQzVDLE9BQVEsaUJBQWdCUixNQUFPLEtBQUlZLGVBQWdCLFVBQVNBLGVBQWdCLE9BQU1aLE1BQU8sZ0JBQWU7QUFDNUc7QUFDQSxTQUFTSixxQ0FBcUNBLENBQUNpQixLQUFLLEVBQUVDLFVBQVUsRUFBRTtFQUM5RCxNQUFNLElBQUlULHdCQUF3QixDQUFDVSxxQkFBcUIsQ0FBRSxTQUFRRixLQUFNLG9EQUFtREMsVUFBVyw0SEFBMkgsQ0FBQztBQUN0UTtBQUNBLFNBQVNqQixxREFBcURBLENBQUNnQixLQUFLLEVBQUVDLFVBQVUsRUFBRTtFQUM5RSxNQUFNLElBQUlULHdCQUF3QixDQUFDVSxxQkFBcUIsQ0FBRSxTQUFRRixLQUFNLCtFQUE4RUMsVUFBVyw0SEFBMkgsQ0FBQztBQUNqUztBQUNBLE1BQU1oQixtQkFBbUIsR0FBRyxJQUFJa0IsR0FBRyxDQUFDLENBQ2hDLGdCQUFnQixFQUNoQixlQUFlLEVBQ2Ysc0JBQXNCLEVBQ3RCLFVBQVUsRUFDVixTQUFTLEVBQ1QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxNQUFNLEVBQ04sT0FBTyxFQUNQLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxRQUFRLEVBQ1IsVUFBVSxFQUNWLFlBQVksQ0FDZixDQUFDIiwic291cmNlcyI6WyIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0L3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5OiBudWxsLFxuICAgIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3M6IG51bGwsXG4gICAgdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcjogbnVsbCxcbiAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcjogbnVsbCxcbiAgICB3ZWxsS25vd25Qcm9wZXJ0aWVzOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHk7XG4gICAgfSxcbiAgICBkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3M7XG4gICAgfSxcbiAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3I7XG4gICAgfSxcbiAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcjtcbiAgICB9LFxuICAgIHdlbGxLbm93blByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2VsbEtub3duUHJvcGVydGllcztcbiAgICB9XG59KTtcbmNvbnN0IF9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dCA9IHJlcXVpcmUoXCIuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0XCIpO1xuLy8gVGhpcyByZWdleCB3aWxsIGhhdmUgZmFzdCBuZWdhdGl2ZXMgbWVhbmluZyB2YWxpZCBpZGVudGlmaWVycyBtYXkgbm90IHBhc3Ncbi8vIHRoaXMgdGVzdC4gSG93ZXZlciB0aGlzIGlzIG9ubHkgdXNlZCBkdXJpbmcgc3RhdGljIGdlbmVyYXRpb24gdG8gcHJvdmlkZSBoaW50c1xuLy8gYWJvdXQgd2h5IGEgcGFnZSBiYWlsZWQgb3V0IG9mIHNvbWUgb3IgYWxsIHByZXJlbmRlcmluZyBhbmQgd2UgY2FuIHVzZSBicmFja2V0IG5vdGF0aW9uXG4vLyBmb3IgZXhhbXBsZSB3aGlsZSBg4LKgX+CyoGAgaXMgYSB2YWxpZCBpZGVudGlmaWVyIGl0J3Mgb2sgdG8gcHJpbnQgYHNlYXJjaFBhcmFtc1sn4LKgX+CyoCddYFxuLy8gZXZlbiBpZiB0aGlzIHdvdWxkIGhhdmUgYmVlbiBmaW5lIHRvbyBgc2VhcmNoUGFyYW1zLuCyoF/gsqBgXG5jb25zdCBpc0RlZmluaXRlbHlBVmFsaWRJZGVudGlmaWVyID0gL15bQS1aYS16XyRdW0EtWmEtejAtOV8kXSokLztcbmZ1bmN0aW9uIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3ModGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKGlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIudGVzdChwcm9wKSkge1xuICAgICAgICByZXR1cm4gYFxcYCR7dGFyZ2V0fS4ke3Byb3B9XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcXGAke3RhcmdldH1bJHtKU09OLnN0cmluZ2lmeShwcm9wKX1dXFxgYDtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZFByb3AgPSBKU09OLnN0cmluZ2lmeShwcm9wKTtcbiAgICByZXR1cm4gYFxcYFJlZmxlY3QuaGFzKCR7dGFyZ2V0fSwgJHtzdHJpbmdpZmllZFByb3B9KVxcYCwgXFxgJHtzdHJpbmdpZmllZFByb3B9IGluICR7dGFyZ2V0fVxcYCwgb3Igc2ltaWxhcmA7XG59XG5mdW5jdGlvbiB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IF9zdGF0aWNnZW5lcmF0aW9uYmFpbG91dC5TdGF0aWNHZW5CYWlsb3V0RXJyb3IoYFJvdXRlICR7cm91dGV9IGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2ApO1xufVxuZnVuY3Rpb24gdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LlN0YXRpY0dlbkJhaWxvdXRFcnJvcihgUm91dGUgJHtyb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2ApO1xufVxuY29uc3Qgd2VsbEtub3duUHJvcGVydGllcyA9IG5ldyBTZXQoW1xuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ3RvU3RyaW5nJyxcbiAgICAndmFsdWVPZicsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAvLyBQcm9taXNlIHByb3RvdHlwZVxuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgJ3RoZW4nLFxuICAgICdjYXRjaCcsXG4gICAgJ2ZpbmFsbHknLFxuICAgIC8vIFJlYWN0IFByb21pc2UgZXh0ZW5zaW9uXG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICAnc3RhdHVzJyxcbiAgICAvLyBSZWFjdCBpbnRyb3NwZWN0aW9uXG4gICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICAvLyBDb21tb24gdGVzdGVkIHByb3BlcnRpZXNcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgICd0b0pTT04nLFxuICAgICckJHR5cGVvZicsXG4gICAgJ19fZXNNb2R1bGUnXG5dKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5IiwiZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyIsInRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3IiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvciIsIndlbGxLbm93blByb3BlcnRpZXMiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQiLCJyZXF1aXJlIiwiaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllciIsInByb3AiLCJ0ZXN0IiwiSlNPTiIsInN0cmluZ2lmeSIsInN0cmluZ2lmaWVkUHJvcCIsInJvdXRlIiwiZXhwcmVzc2lvbiIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIlNldCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"ReflectAdapter\", ({\n  enumerable: true,\n  get: function () {\n    return ReflectAdapter;\n  }\n}));\nclass ReflectAdapter {\n  static get(target, prop, receiver) {\n    const value = Reflect.get(target, prop, receiver);\n    if (typeof value === 'function') {\n      return value.bind(target);\n    }\n    return value;\n  }\n  static set(target, prop, value, receiver) {\n    return Reflect.set(target, prop, value, receiver);\n  }\n  static has(target, prop) {\n    return Reflect.has(target, prop);\n  }\n  static deleteProperty(target, prop) {\n    return Reflect.deleteProperty(target, prop);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7RUFDN0NJLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ1osT0FBT0MsY0FBYztFQUN6QjtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1BLGNBQWMsQ0FBQztFQUNqQixPQUFPRCxHQUFHQSxDQUFDRSxNQUFNLEVBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQy9CLE1BQU1OLEtBQUssR0FBR08sT0FBTyxDQUFDTCxHQUFHLENBQUNFLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLENBQUM7SUFDakQsSUFBSSxPQUFPTixLQUFLLEtBQUssVUFBVSxFQUFFO01BQzdCLE9BQU9BLEtBQUssQ0FBQ1EsSUFBSSxDQUFDSixNQUFNLENBQUM7SUFDN0I7SUFDQSxPQUFPSixLQUFLO0VBQ2hCO0VBQ0EsT0FBT1MsR0FBR0EsQ0FBQ0wsTUFBTSxFQUFFQyxJQUFJLEVBQUVMLEtBQUssRUFBRU0sUUFBUSxFQUFFO0lBQ3RDLE9BQU9DLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDTCxNQUFNLEVBQUVDLElBQUksRUFBRUwsS0FBSyxFQUFFTSxRQUFRLENBQUM7RUFDckQ7RUFDQSxPQUFPSSxHQUFHQSxDQUFDTixNQUFNLEVBQUVDLElBQUksRUFBRTtJQUNyQixPQUFPRSxPQUFPLENBQUNHLEdBQUcsQ0FBQ04sTUFBTSxFQUFFQyxJQUFJLENBQUM7RUFDcEM7RUFDQSxPQUFPTSxjQUFjQSxDQUFDUCxNQUFNLEVBQUVDLElBQUksRUFBRTtJQUNoQyxPQUFPRSxPQUFPLENBQUNJLGNBQWMsQ0FBQ1AsTUFBTSxFQUFFQyxJQUFJLENBQUM7RUFDL0M7QUFDSiIsInNvdXJjZXMiOlsiL2hvbWUvbWF4L2Rldi9wcmlzbWEtZmFybWFjaWEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWZsZWN0QWRhcHRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXI7XG4gICAgfVxufSk7XG5jbGFzcyBSZWZsZWN0QWRhcHRlciB7XG4gICAgc3RhdGljIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJSZWZsZWN0QWRhcHRlciIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJiaW5kIiwic2V0IiwiaGFzIiwiZGVsZXRlUHJvcGVydHkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-page.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientPageRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientPageRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction ClientPageRoot(param) {\n    let { Component, searchParams, params, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    promises } = param;\n    if (typeof window === 'undefined') {\n        const { workAsyncStorage } = __webpack_require__(/*! ../../server/app-render/work-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-async-storage.external.js\");\n        let clientSearchParams;\n        let clientParams;\n        // We are going to instrument the searchParams prop with tracking for the\n        // appropriate context. We wrap differently in prerendering vs rendering\n        const store = workAsyncStorage.getStore();\n        if (!store) {\n            throw new _invarianterror.InvariantError('Expected workStore to exist when handling searchParams in a client Page.');\n        }\n        const { createSearchParamsFromClient } = __webpack_require__(/*! ../../server/request/search-params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js\");\n        clientSearchParams = createSearchParamsFromClient(searchParams, store);\n        const { createParamsFromClient } = __webpack_require__(/*! ../../server/request/params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.js\");\n        clientParams = createParamsFromClient(params, store);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    } else {\n        const { createRenderSearchParamsFromClient } = __webpack_require__(/*! ../../server/request/search-params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js\");\n        const clientSearchParams = createRenderSearchParamsFromClient(searchParams);\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../../server/request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    }\n}\n_c = ClientPageRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c;\n$RefreshReg$(_c, \"ClientPageRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMiLCJtYXBwaW5ncyI6InFEQUVhO0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGtEQUFpRDtJQUM3Q0ksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDWixPQUFPQyxjQUFjO0lBQ3pCO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsV0FBVyxHQUFHQyxtQkFBTyxDQUFDLHFHQUFtQixDQUFDO0FBQ2hELE1BQU1DLGVBQWUsR0FBR0QsbUJBQU8sQ0FBQyxvSEFBa0MsQ0FBQztBQUNuRSx3QkFBd0JFLEtBQUssRUFBRTtJQUMzQixJQUFJLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyxNQUFNLEVBQUU7SUFDdkNDLFFBQUFBLEVBQVUsR0FBR0osS0FBSztJQUNsQixJQUFJLE9BQU9LLE1BQU0sS0FBSyxXQUFXLEVBQUU7UUFDL0IsTUFBTSxFQUFFQyxnQkFBQUEsRUFBa0IsR0FBR1IsbUJBQU8sQ0FBQywrSUFBcUQsQ0FBQztRQUMzRixJQUFJUyxrQkFBa0I7UUFDdEIsSUFBSUMsWUFBWTtRQUNoQjtRQUNBO1FBQ0EsTUFBTUMsS0FBSyxHQUFHSCxnQkFBZ0IsQ0FBQ0ksUUFBUSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDRCxLQUFLLEVBQUU7WUFDUixNQUFNLElBQUlWLGVBQWUsQ0FBQ1ksY0FBYyxDQUFDLDBFQUEwRSxDQUFDO1FBQ3hIO1FBQ0EsTUFBTSxFQUFFQyw0QkFBQUEsRUFBOEIsR0FBR2QsbUJBQU8sQ0FBQyx3SEFBb0MsQ0FBQztRQUN0RlMsa0JBQWtCLEdBQUdLLDRCQUE0QixDQUFDVixZQUFZLEVBQUVPLEtBQUssQ0FBQztRQUN0RSxNQUFNLEVBQUVJLHNCQUFBQSxFQUF3QixHQUFHZixtQkFBTyxDQUFDLDBHQUE2QixDQUFDO1FBQ3pFVSxZQUFZLEdBQUdLLHNCQUFzQixDQUFDVixNQUFNLEVBQUVNLEtBQUssQ0FBQztRQUNwRCxPQUFPLGVBQWUsQ0FBQyxFQUFFWixXQUFXLENBQUNpQixHQUFBQSxFQUFLYixTQUFTLEVBQUU7WUFDakRFLE1BQU0sRUFBRUssWUFBWTtZQUNwQk4sWUFBWSxFQUFFSztRQUNsQixDQUFDLENBQUM7SUFDTixDQUFDLE1BQU07UUFDSCxNQUFNLEVBQUVRLGtDQUFBQSxFQUFvQyxHQUFHakIsbUJBQU8sQ0FBQyx3SUFBNEMsQ0FBQztRQUNwRyxNQUFNUyxrQkFBa0IsR0FBR1Esa0NBQWtDLENBQUNiLFlBQVksQ0FBQztRQUMzRSxNQUFNLEVBQUVjLDRCQUFBQSxFQUE4QixHQUFHbEIsbUJBQU8sQ0FBQywwSEFBcUMsQ0FBQztRQUN2RixNQUFNVSxZQUFZLEdBQUdRLDRCQUE0QixDQUFDYixNQUFNLENBQUM7UUFDekQsT0FBTyxlQUFlLENBQUMsRUFBRU4sV0FBVyxDQUFDaUIsR0FBQUEsRUFBS2IsU0FBUyxFQUFFO1lBQ2pERSxNQUFNLEVBQUVLLFlBQVk7WUFDcEJOLFlBQVksRUFBRUs7UUFDbEIsQ0FBQyxDQUFDO0lBQ047QUFDSjtLQS9CU1gsY0FBY0E7QUFpQ3ZCLElBQUksQ0FBQyxPQUFPSixPQUFPLENBQUN5QixPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU96QixPQUFPLENBQUN5QixPQUFPLEtBQUssUUFBUSxJQUFJekIsT0FBTyxDQUFDeUIsT0FBTyxLQUFLLEtBQUssSUFBSyxPQUFPekIsT0FBTyxDQUFDeUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssV0FBVyxFQUFFO0lBQ3JLNUIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sQ0FBQ3lCLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRXhCLEtBQUssRUFBRTtJQUFLLENBQUMsQ0FBQztJQUNyRUgsTUFBTSxDQUFDNkIsTUFBTSxDQUFDM0IsT0FBTyxDQUFDeUIsT0FBTyxFQUFFekIsT0FBTyxDQUFDO0lBQ3ZDNEIsTUFBTSxDQUFDNUIsT0FBTyxHQUFHQSxPQUFPLENBQUN5QixPQUFPO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1wYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudFBhZ2VSb290XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDbGllbnRQYWdlUm9vdDtcbiAgICB9XG59KTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX2ludmFyaWFudGVycm9yID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yXCIpO1xuZnVuY3Rpb24gQ2xpZW50UGFnZVJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBDb21wb25lbnQsIHNlYXJjaFBhcmFtcywgcGFyYW1zLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcHJvbWlzZXMgfSA9IHBhcmFtO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB7IHdvcmtBc3luY1N0b3JhZ2UgfSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpO1xuICAgICAgICBsZXQgY2xpZW50U2VhcmNoUGFyYW1zO1xuICAgICAgICBsZXQgY2xpZW50UGFyYW1zO1xuICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gaW5zdHJ1bWVudCB0aGUgc2VhcmNoUGFyYW1zIHByb3Agd2l0aCB0cmFja2luZyBmb3IgdGhlXG4gICAgICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRleHQuIFdlIHdyYXAgZGlmZmVyZW50bHkgaW4gcHJlcmVuZGVyaW5nIHZzIHJlbmRlcmluZ1xuICAgICAgICBjb25zdCBzdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IF9pbnZhcmlhbnRlcnJvci5JbnZhcmlhbnRFcnJvcignRXhwZWN0ZWQgd29ya1N0b3JlIHRvIGV4aXN0IHdoZW4gaGFuZGxpbmcgc2VhcmNoUGFyYW1zIGluIGEgY2xpZW50IFBhZ2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IH0gPSByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zJyk7XG4gICAgICAgIGNsaWVudFNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQoc2VhcmNoUGFyYW1zLCBzdG9yZSk7XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlUGFyYW1zRnJvbUNsaWVudCB9ID0gcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJyk7XG4gICAgICAgIGNsaWVudFBhcmFtcyA9IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQocGFyYW1zLCBzdG9yZSk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKENvbXBvbmVudCwge1xuICAgICAgICAgICAgcGFyYW1zOiBjbGllbnRQYXJhbXMsXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IGNsaWVudFNlYXJjaFBhcmFtc1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQgfSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3NlYXJjaC1wYXJhbXMuYnJvd3NlcicpO1xuICAgICAgICBjb25zdCBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCB9ID0gcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zLmJyb3dzZXInKTtcbiAgICAgICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShDb21wb25lbnQsIHtcbiAgICAgICAgICAgIHBhcmFtczogY2xpZW50UGFyYW1zLFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiBjbGllbnRTZWFyY2hQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtcGFnZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQ2xpZW50UGFnZVJvb3QiLCJfanN4cnVudGltZSIsInJlcXVpcmUiLCJfaW52YXJpYW50ZXJyb3IiLCJwYXJhbSIsIkNvbXBvbmVudCIsInNlYXJjaFBhcmFtcyIsInBhcmFtcyIsInByb21pc2VzIiwid2luZG93Iiwid29ya0FzeW5jU3RvcmFnZSIsImNsaWVudFNlYXJjaFBhcmFtcyIsImNsaWVudFBhcmFtcyIsInN0b3JlIiwiZ2V0U3RvcmUiLCJJbnZhcmlhbnRFcnJvciIsImNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwianN4IiwiY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-segment.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientSegmentRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientSegmentRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction ClientSegmentRoot(param) {\n    let { Component, slots, params, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    promise } = param;\n    if (typeof window === 'undefined') {\n        const { workAsyncStorage } = __webpack_require__(/*! ../../server/app-render/work-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-async-storage.external.js\");\n        let clientParams;\n        // We are going to instrument the searchParams prop with tracking for the\n        // appropriate context. We wrap differently in prerendering vs rendering\n        const store = workAsyncStorage.getStore();\n        if (!store) {\n            throw new _invarianterror.InvariantError('Expected workStore to exist when handling params in a client segment such as a Layout or Template.');\n        }\n        const { createParamsFromClient } = __webpack_require__(/*! ../../server/request/params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.js\");\n        clientParams = createParamsFromClient(params, store);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    } else {\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../../server/request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    }\n}\n_c = ClientSegmentRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c;\n$RefreshReg$(_c, \"ClientSegmentRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQuanMiLCJtYXBwaW5ncyI6InFEQUVhO0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHFEQUFvRDtJQUNoREksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDWixPQUFPQyxpQkFBaUI7SUFDNUI7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxXQUFXLEdBQUdDLG1CQUFPLENBQUMscUdBQW1CLENBQUM7QUFDaEQsTUFBTUMsZUFBZSxHQUFHRCxtQkFBTyxDQUFDLG9IQUFrQyxDQUFDO0FBQ25FLDJCQUEyQkUsS0FBSyxFQUFFO0lBQzlCLElBQUksRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtJQUNoQ0MsT0FBQUEsRUFBUyxHQUFHSixLQUFLO0lBQ2pCLElBQUksT0FBT0ssTUFBTSxLQUFLLFdBQVcsRUFBRTtRQUMvQixNQUFNLEVBQUVDLGdCQUFBQSxFQUFrQixHQUFHUixtQkFBTyxDQUFDLCtJQUFxRCxDQUFDO1FBQzNGLElBQUlTLFlBQVk7UUFDaEI7UUFDQTtRQUNBLE1BQU1DLEtBQUssR0FBR0YsZ0JBQWdCLENBQUNHLFFBQVEsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQ0QsS0FBSyxFQUFFO1lBQ1IsTUFBTSxJQUFJVCxlQUFlLENBQUNXLGNBQWMsQ0FBQyxvR0FBb0csQ0FBQztRQUNsSjtRQUNBLE1BQU0sRUFBRUMsc0JBQUFBLEVBQXdCLEdBQUdiLG1CQUFPLENBQUMsMEdBQTZCLENBQUM7UUFDekVTLFlBQVksR0FBR0ksc0JBQXNCLENBQUNSLE1BQU0sRUFBRUssS0FBSyxDQUFDO1FBQ3BELE9BQU8sZUFBZSxDQUFDLEVBQUVYLFdBQVcsQ0FBQ2UsR0FBQUEsRUFBS1gsU0FBUyxFQUFFO1lBQ2pELEdBQUdDLEtBQUs7WUFDUkMsTUFBTSxFQUFFSTtRQUNaLENBQUMsQ0FBQztJQUNOLENBQUMsTUFBTTtRQUNILE1BQU0sRUFBRU0sNEJBQUFBLEVBQThCLEdBQUdmLG1CQUFPLENBQUMsMEhBQXFDLENBQUM7UUFDdkYsTUFBTVMsWUFBWSxHQUFHTSw0QkFBNEIsQ0FBQ1YsTUFBTSxDQUFDO1FBQ3pELE9BQU8sZUFBZSxDQUFDLEVBQUVOLFdBQVcsQ0FBQ2UsR0FBQUEsRUFBS1gsU0FBUyxFQUFFO1lBQ2pELEdBQUdDLEtBQUs7WUFDUkMsTUFBTSxFQUFFSTtRQUNaLENBQUMsQ0FBQztJQUNOO0FBQ0o7S0ExQlNYLGlCQUFpQkE7QUE0QjFCLElBQUksQ0FBQyxPQUFPSixPQUFPLENBQUNzQixPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU90QixPQUFPLENBQUNzQixPQUFPLEtBQUssUUFBUSxJQUFJdEIsT0FBTyxDQUFDc0IsT0FBTyxLQUFLLEtBQUssSUFBSyxPQUFPdEIsT0FBTyxDQUFDc0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssV0FBVyxFQUFFO0lBQ3JLekIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sQ0FBQ3NCLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRXJCLEtBQUssRUFBRTtJQUFLLENBQUMsQ0FBQztJQUNyRUgsTUFBTSxDQUFDMEIsTUFBTSxDQUFDeEIsT0FBTyxDQUFDc0IsT0FBTyxFQUFFdEIsT0FBTyxDQUFDO0lBQ3ZDeUIsTUFBTSxDQUFDekIsT0FBTyxHQUFHQSxPQUFPLENBQUNzQixPQUFPO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1zZWdtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudFNlZ21lbnRSb290XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDbGllbnRTZWdtZW50Um9vdDtcbiAgICB9XG59KTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX2ludmFyaWFudGVycm9yID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yXCIpO1xuZnVuY3Rpb24gQ2xpZW50U2VnbWVudFJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBDb21wb25lbnQsIHNsb3RzLCBwYXJhbXMsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBwcm9taXNlIH0gPSBwYXJhbTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPSByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnKTtcbiAgICAgICAgbGV0IGNsaWVudFBhcmFtcztcbiAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGluc3RydW1lbnQgdGhlIHNlYXJjaFBhcmFtcyBwcm9wIHdpdGggdHJhY2tpbmcgZm9yIHRoZVxuICAgICAgICAvLyBhcHByb3ByaWF0ZSBjb250ZXh0LiBXZSB3cmFwIGRpZmZlcmVudGx5IGluIHByZXJlbmRlcmluZyB2cyByZW5kZXJpbmdcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgIGlmICghc3RvcmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBfaW52YXJpYW50ZXJyb3IuSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIHdvcmtTdG9yZSB0byBleGlzdCB3aGVuIGhhbmRsaW5nIHBhcmFtcyBpbiBhIGNsaWVudCBzZWdtZW50IHN1Y2ggYXMgYSBMYXlvdXQgb3IgVGVtcGxhdGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IH0gPSByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMnKTtcbiAgICAgICAgY2xpZW50UGFyYW1zID0gY3JlYXRlUGFyYW1zRnJvbUNsaWVudChwYXJhbXMsIHN0b3JlKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAuLi5zbG90cyxcbiAgICAgICAgICAgIHBhcmFtczogY2xpZW50UGFyYW1zXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCB9ID0gcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zLmJyb3dzZXInKTtcbiAgICAgICAgY29uc3QgY2xpZW50UGFyYW1zID0gY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShDb21wb25lbnQsIHtcbiAgICAgICAgICAgIC4uLnNsb3RzLFxuICAgICAgICAgICAgcGFyYW1zOiBjbGllbnRQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtc2VnbWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQ2xpZW50U2VnbWVudFJvb3QiLCJfanN4cnVudGltZSIsInJlcXVpcmUiLCJfaW52YXJpYW50ZXJyb3IiLCJwYXJhbSIsIkNvbXBvbmVudCIsInNsb3RzIiwicGFyYW1zIiwicHJvbWlzZSIsIndpbmRvdyIsIndvcmtBc3luY1N0b3JhZ2UiLCJjbGllbnRQYXJhbXMiLCJzdG9yZSIsImdldFN0b3JlIiwiSW52YXJpYW50RXJyb3IiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwianN4IiwiY3JlYXRlUmVuZGVyUGFyYW1zRnJvbUNsaWVudCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return OuterLayoutRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _notfoundboundary = __webpack_require__(/*! ./not-found-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\");\nconst _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./router-reducer/reducers/has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                'refetch'\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (typeof window === 'undefined') return null;\n    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n    // We need to lazily reference it.\n    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;\n    return internal_reactDOMfindDOMNode(instance);\n}\nconst rectProperties = [\n    'bottom',\n    'height',\n    'left',\n    'right',\n    'top',\n    'width',\n    'x',\n    'y'\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        'sticky',\n        'fixed'\n    ].includes(getComputedStyle(element).position)) {\n        if (true) {\n            console.warn('Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:', element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === 'top') {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args);\n        this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath, children } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error('invariant global layout router not mounted');\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n_c = ScrollAndFocusHandler;\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey, url, childNodes, segmentPath, tree, // TODO-APP: implement `<Offscreen>` when available.\n    // isActive,\n    cacheKey } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error('invariant global layout router not mounted');\n    }\n    const { buildId, changeByServerResponse, tree: fullTree } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(cacheKey);\n    // When data is not available during rendering client-side we need to fetch\n    // it from the server.\n    if (childNode === undefined) {\n        const newLazyCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(),\n            loading: null\n        };\n        /**\n    * Flight data fetch kicked off during render and put into the cache.\n    */ childNode = newLazyCacheNode;\n        childNodes.set(cacheKey, newLazyCacheNode);\n    }\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    //\n    // @ts-expect-error The second argument to `useDeferredValue` is only\n    // available in the experimental builds. When its disabled, it will always\n    // return `rsc`.\n    const rsc = (0, _react.useDeferredValue)(childNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? (0, _react.use)(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Check if there's already a pending request.\n        let lazyData = childNode.lazyData;\n        if (lazyData === null) {\n            /**\n      * Router state with refetch marker added\n      */ // TODO-APP: remove ''\n            const refetchTree = walkAddRefetch([\n                '',\n                ...segmentPath\n            ], fullTree);\n            const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);\n            childNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), {\n                flightRouterState: refetchTree,\n                nextUrl: includeNextUrl ? context.nextUrl : null,\n                buildId\n            }).then((serverResponse)=>{\n                (0, _react.startTransition)(()=>{\n                    changeByServerResponse({\n                        previousTree: fullTree,\n                        serverResponse\n                    });\n                });\n                return serverResponse;\n            });\n        }\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    // If we get to this point, then we know we have something we can render.\n    const subtree = // The layout router context narrows down tree and childNodes at each level.\n    /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url,\n            loading: childNode.loading\n        },\n        children: resolvedRsc\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children, hasLoading, loading, loadingStyles, loadingScripts } = param;\n    // We have an explicit prop for checking if `loading` is provided, to disambiguate between a loading\n    // component that returns `null` / `undefined`, vs not having a loading component at all.\n    if (hasLoading) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loading\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c2 = LoadingBoundary;\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, notFoundStyles } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    if (!context) {\n        throw new Error('invariant expected layout router to be mounted');\n    }\n    const { childNodes, tree, url, loading } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodesForParallelRouter = new Map();\n        childNodes.set(parallelRouterKey, childNodesForParallelRouter);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);\n    /**\n  * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n  */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: preservedSegments.map((preservedSegment)=>{\n            const preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);\n            const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);\n            return(/*\n        - Error boundary\n        - Only renders error boundary if error component is provided.\n        - Rendered for each segment to ensure they have their own error state.\n        - Loading boundary\n        - Only renders suspense boundary if loading components is provided.\n        - Rendered for each segment to ensure they have their own loading state.\n        - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n        */ /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {\n                value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ScrollAndFocusHandler, {\n                    segmentPath: segmentPath,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n                        errorComponent: error,\n                        errorStyles: errorStyles,\n                        errorScripts: errorScripts,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {\n                            hasLoading: Boolean(loading),\n                            loading: loading == null ? void 0 : loading[0],\n                            loadingStyles: loading == null ? void 0 : loading[1],\n                            loadingScripts: loading == null ? void 0 : loading[2],\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_notfoundboundary.NotFoundBoundary, {\n                                notFound: notFound,\n                                notFoundStyles: notFoundStyles,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_redirectboundary.RedirectBoundary, {\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {\n                                        parallelRouterKey: parallelRouterKey,\n                                        url: url,\n                                        tree: tree,\n                                        childNodes: childNodesForParallelRouter,\n                                        segmentPath: segmentPath,\n                                        cacheKey: cacheKey,\n                                        isActive: currentChildSegmentValue === preservedSegmentValue\n                                    })\n                                })\n                            })\n                        })\n                    })\n                }),\n                children: [\n                    templateStyles,\n                    templateScripts,\n                    template\n                ]\n            }, (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true)));\n        })\n    });\n}\n_c3 = OuterLayoutRouter;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBR2U7SUFDWEksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDWixPQUFPQyxpQkFBaUI7SUFDNUI7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyx3QkFBd0IsR0FBR0MsbUJBQU8sQ0FBQyxnSUFBeUMsQ0FBQztBQUNuRixNQUFNQyx5QkFBeUIsR0FBR0QsbUJBQU8sQ0FBQyxrSUFBMEMsQ0FBQztBQUNyRixNQUFNRSxXQUFXLEdBQUdGLG1CQUFPLENBQUMscUdBQW1CLENBQUM7QUFDaEQsTUFBTUcsTUFBTSxHQUFHLGNBQWNGLHlCQUF5QixDQUFDRyxDQUFDLENBQUNKLG1CQUFPLENBQUMsbUZBQU8sQ0FBQyxDQUFDO0FBQzFFLE1BQU1LLFNBQVMsR0FBRyxjQUFjTix3QkFBd0IsQ0FBQ0ssQ0FBQyxDQUFDSixtQkFBTyxDQUFDLDJGQUFXLENBQUMsQ0FBQztBQUNoRixNQUFNTSw4QkFBOEIsR0FBR04sbUJBQU8sQ0FBQyx3SkFBb0QsQ0FBQztBQUNwRyxNQUFNTyxvQkFBb0IsR0FBR1AsbUJBQU8sQ0FBQyxzSkFBd0MsQ0FBQztBQUM5RSxNQUFNUSxtQkFBbUIsR0FBR1IsbUJBQU8sQ0FBQyxvSEFBdUIsQ0FBQztBQUM1RCxNQUFNUyxjQUFjLEdBQUdULG1CQUFPLENBQUMsMEdBQWtCLENBQUM7QUFDbEQsTUFBTVUsY0FBYyxHQUFHVixtQkFBTyxDQUFDLDBHQUFrQixDQUFDO0FBQ2xELE1BQU1XLG1CQUFtQixHQUFHWCxtQkFBTyxDQUFDLHdKQUFvRCxDQUFDO0FBQ3pGLE1BQU1ZLGlCQUFpQixHQUFHWixtQkFBTyxDQUFDLGdIQUFxQixDQUFD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LENBQUNvQyxPQUFPO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIC8qKlxuICogT3V0ZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyB0aGUgY3VycmVudCBzZWdtZW50IGFzIHdlbGwgYXMgPE9mZnNjcmVlbj4gcmVuZGVyaW5nIG9mIG90aGVyIHNlZ21lbnRzLlxuICogSXQgY2FuIGJlIHJlbmRlcmVkIG5leHQgdG8gZWFjaCBvdGhlciB3aXRoIGEgZGlmZmVyZW50IGBwYXJhbGxlbFJvdXRlcktleWAsIGFsbG93aW5nIGZvciBQYXJhbGxlbCByb3V0ZXMuXG4gKi8gXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPdXRlckxheW91dFJvdXRlcjtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVhY3Rkb20gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2ZldGNoc2VydmVycmVzcG9uc2UgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG5jb25zdCBfdW5yZXNvbHZlZHRoZW5hYmxlID0gcmVxdWlyZShcIi4vdW5yZXNvbHZlZC10aGVuYWJsZVwiKTtcbmNvbnN0IF9lcnJvcmJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG5jb25zdCBfbWF0Y2hzZWdtZW50cyA9IHJlcXVpcmUoXCIuL21hdGNoLXNlZ21lbnRzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmNvbnN0IF9yZWRpcmVjdGJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vcmVkaXJlY3QtYm91bmRhcnlcIik7XG5jb25zdCBfbm90Zm91bmRib3VuZGFyeSA9IHJlcXVpcmUoXCIuL25vdC1mb3VuZC1ib3VuZGFyeVwiKTtcbmNvbnN0IF9nZXRzZWdtZW50dmFsdWUgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZVwiKTtcbmNvbnN0IF9jcmVhdGVyb3V0ZXJjYWNoZWtleSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1yb3V0ZXItY2FjaGUta2V5XCIpO1xuY29uc3QgX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlXCIpO1xuLyoqXG4gKiBBZGQgcmVmZXRjaCBtYXJrZXIgdG8gcm91dGVyIHN0YXRlIGF0IHRoZSBwb2ludCBvZiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqIFRoaXMgZW5zdXJlcyB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgaXMgbm90IGZ1cnRoZXIgZG93biB0aGFuIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICovIGZ1bmN0aW9uIHdhbGtBZGRSZWZldGNoKHNlZ21lbnRQYXRoVG9XYWxrLCB0cmVlVG9SZWNyZWF0ZSkge1xuICAgIGlmIChzZWdtZW50UGF0aFRvV2Fsaykge1xuICAgICAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBzZWdtZW50UGF0aFRvV2FsaztcbiAgICAgICAgY29uc3QgaXNMYXN0ID0gc2VnbWVudFBhdGhUb1dhbGsubGVuZ3RoID09PSAyO1xuICAgICAgICBpZiAoKDAsIF9tYXRjaHNlZ21lbnRzLm1hdGNoU2VnbWVudCkodHJlZVRvUmVjcmVhdGVbMF0sIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICBpZiAodHJlZVRvUmVjcmVhdGVbMV0uaGFzT3duUHJvcGVydHkocGFyYWxsZWxSb3V0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSB3YWxrQWRkUmVmZXRjaCh1bmRlZmluZWQsIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRyZWVUb1JlY3JlYXRlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVmZXRjaCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG5jb25zdCBfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUgPSBfcmVhY3Rkb20uZGVmYXVsdC5fX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREU7XG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi8gZnVuY3Rpb24gZmluZERPTU5vZGUoaW5zdGFuY2UpIHtcbiAgICAvLyBUcmVlLXNoYWtlIGZvciBzZXJ2ZXIgYnVuZGxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgICAvLyBfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUuZmluZERPTU5vZGUgaXMgbnVsbCBkdXJpbmcgbW9kdWxlIGluaXQuXG4gICAgLy8gV2UgbmVlZCB0byBsYXppbHkgcmVmZXJlbmNlIGl0LlxuICAgIGNvbnN0IGludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUgPSBfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUuZmluZERPTU5vZGU7XG4gICAgcmV0dXJuIGludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUoaW5zdGFuY2UpO1xufVxuY29uc3QgcmVjdFByb3BlcnRpZXMgPSBbXG4gICAgJ2JvdHRvbScsXG4gICAgJ2hlaWdodCcsXG4gICAgJ2xlZnQnLFxuICAgICdyaWdodCcsXG4gICAgJ3RvcCcsXG4gICAgJ3dpZHRoJyxcbiAgICAneCcsXG4gICAgJ3knXG5dO1xuLyoqXG4gKiBDaGVjayBpZiBhIEhUTUxFbGVtZW50IGlzIGhpZGRlbiBvciBmaXhlZC9zdGlja3kgcG9zaXRpb25cbiAqLyBmdW5jdGlvbiBzaG91bGRTa2lwRWxlbWVudChlbGVtZW50KSB7XG4gICAgLy8gd2UgaWdub3JlIGZpeGVkIG9yIHN0aWNreSBwb3NpdGlvbmVkIGVsZW1lbnRzIHNpbmNlIHRoZXknbGwgbGlrZWx5IHBhc3MgdGhlIFwiaW4tdmlld3BvcnRcIiBjaGVja1xuICAgIC8vIGFuZCB3aWxsIHJlc3VsdCBpbiBhIHNpdHVhdGlvbiB3ZSBiYWlsIG9uIHNjcm9sbCBiZWNhdXNlIG9mIHNvbWV0aGluZyBsaWtlIGEgZml4ZWQgbmF2LFxuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZSBhY3R1YWwgcGFnZSBjb250ZW50IGlzIG9mZnNjcmVlblxuICAgIGlmIChbXG4gICAgICAgICdzdGlja3knLFxuICAgICAgICAnZml4ZWQnXG4gICAgXS5pbmNsdWRlcyhnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU2tpcHBpbmcgYXV0by1zY3JvbGwgYmVoYXZpb3IgZHVlIHRvIGBwb3NpdGlvbjogc3RpY2t5YCBvciBgcG9zaXRpb246IGZpeGVkYCBvbiBlbGVtZW50OicsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBVc2VzIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIHRvIGNoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBpbnN0ZWFkIG9mIGBvZmZzZXRQYXJlbnRgXG4gICAgLy8gYmVjYXVzZSBgb2Zmc2V0UGFyZW50YCBkb2Vzbid0IGNvbnNpZGVyIGRvY3VtZW50L2JvZHlcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdFByb3BlcnRpZXMuZXZlcnkoKGl0ZW0pPT5yZWN0W2l0ZW1dID09PSAwKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRvcCBjb3JuZXIgb2YgdGhlIEhUTUxFbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAqLyBmdW5jdGlvbiB0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQsIHZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QudG9wID49IDAgJiYgcmVjdC50b3AgPD0gdmlld3BvcnRIZWlnaHQ7XG59XG4vKipcbiAqIEZpbmQgdGhlIERPTSBub2RlIGZvciBhIGhhc2ggZnJhZ21lbnQuXG4gKiBJZiBgdG9wYCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuIFRoaXMgbWlycm9ycyB0aGUgYnJvd3NlcidzIGJlaGF2aW9yLlxuICogSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYW4gaWQsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGF0IGlkLlxuICogSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYSBuYW1lLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggdGhhdCBuYW1lLlxuICovIGZ1bmN0aW9uIGdldEhhc2hGcmFnbWVudERvbU5vZGUoaGFzaEZyYWdtZW50KSB7XG4gICAgLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYHRvcGAgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLlxuICAgIGlmIChoYXNoRnJhZ21lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICB2YXIgX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkO1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGFuIGlkLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdpdGggdGhhdCBpZC5cbiAgICByZXR1cm4gKF9kb2N1bWVudF9nZXRFbGVtZW50QnlJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2hGcmFnbWVudCkpICE9IG51bGwgPyBfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQgOiAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoaGFzaEZyYWdtZW50KVswXTtcbn1cbmNsYXNzIElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgb3ZlcndyaXR0ZW4gaW4gaGFuZGxlUG90ZW50aWFsU2Nyb2xsIGl0J3MgZmluZSB0byBhbHdheXMgcnVuIGl0IHdoZW4gdHJ1ZSBhcyBpdCdsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCA9ICgpPT57XG4gICAgICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgY29uc3QgeyBmb2N1c0FuZFNjcm9sbFJlZiwgc2VnbWVudFBhdGggfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWdtZW50UGF0aHMgaXMgYW4gYXJyYXkgb2Ygc2VnbWVudCBwYXRocyB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgcGF0aCBpcyBub3QgaW4gdGhlIGFycmF5LCB0aGUgc2Nyb2xsIGlzIG5vdCBhcHBsaWVkXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIHRoZSBhcnJheSBpcyBlbXB0eSwgaW4gd2hpY2ggY2FzZSB0aGUgc2Nyb2xsIGlzIGFsd2F5cyBhcHBsaWVkXG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5sZW5ndGggIT09IDAgJiYgIWZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocy5zb21lKChzY3JvbGxSZWZTZWdtZW50UGF0aCk9PnNlZ21lbnRQYXRoLmV2ZXJ5KChzZWdtZW50LCBpbmRleCk9PigwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHNlZ21lbnQsIHNjcm9sbFJlZlNlZ21lbnRQYXRoW2luZGV4XSkpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoRnJhZ21lbnQgPSBmb2N1c0FuZFNjcm9sbFJlZi5oYXNoRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc2hGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gZ2V0SGFzaEZyYWdtZW50RG9tTm9kZShoYXNoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgZmluZERPTU5vZGVgIGlzIHRyaWNreSBiZWNhdXNlIGl0IHJldHVybnMganVzdCB0aGUgZmlyc3QgY2hpbGQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGZyYWdtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxyZWFkeSBjYXVzZWQgYSBidWcgd2hlcmUgdGhlIGZpcnN0IGNoaWxkIHdhcyBhIDxsaW5rLz4gaW4gaGVhZC5cbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBET00gbm9kZSB0aGlzIGxheW91dC1yb3V0ZXIgbGV2ZWwgaXMgc2tpcHBlZC4gSXQnbGwgYmUgaGFuZGxlZCBoaWdoZXItdXAgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgICAgICAgaWYgKCEoZG9tTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IGlmIHRoZSBlbGVtZW50IGlzIGEgSFRNTEVsZW1lbnQgYW5kIGlmIHdlIHdhbnQgdG8gY29uc2lkZXIgaXQgZm9yIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBza2lwcGVkLCB0cnkgdG8gc2VsZWN0IHRoZSBuZXh0IHNpYmxpbmcgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICB3aGlsZSghKGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHwgc2hvdWxkU2tpcEVsZW1lbnQoZG9tTm9kZSkpe1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBzaWJsaW5ncyBmb3VuZCB0aGF0IG1hdGNoIHRoZSBjcml0ZXJpYSBhcmUgZm91bmQsIHNvIGhhbmRsZSBzY3JvbGwgaGlnaGVyIHVwIGluIHRoZSB0cmVlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlLm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBkb21Ob2RlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RhdGUgaXMgbXV0YXRlZCB0byBlbnN1cmUgdGhhdCB0aGUgZm9jdXMgYW5kIHNjcm9sbCBpcyBhcHBsaWVkIG9ubHkgb25jZS5cbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5hcHBseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLmhhc2hGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuc2VnbWVudFBhdGhzID0gW107XG4gICAgICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGhhc2ggc2Nyb2xsLCB3ZSBvbmx5IG5lZWQgdG8gc2Nyb2xsIHRoZSBlbGVtZW50IGludG8gdmlld1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgaGVpZ2h0IGJlY2F1c2UgcmVhZGluZyBgY2xpZW50SGVpZ2h0YCBjYXVzZXMgYSByZWZsb3csXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCB3b24ndCBjaGFuZ2UgZHVyaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGh0bWxFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQncyB0b3AgZWRnZSBpcyBhbHJlYWR5IGluIHRoZSB2aWV3cG9ydCwgZXhpdCBlYXJseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0cnkgc2Nyb2xsaW5nIGdvIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUgd2l0aCBwYWdlc1xuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxJbnRvVmlldygpIGNhbGxlZCBvbiBgPGh0bWwvPmAgZWxlbWVudCBzY3JvbGxzIGhvcml6b250YWxseSBvbiBjaHJvbWUgYW5kIGZpcmVmb3ggKHRoYXQgc2hvdWxkbid0IGhhcHBlbilcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgdXNlIGl0IHRvIHNjcm9sbCBob3Jpem9udGFsbHkgZm9sbG93aW5nIFJUTCBidXQgdGhhdCBhbHNvIHNlZW1zIHRvIGJlIGJyb2tlbiAtIGl0IHdpbGwgYWx3YXlzIHNjcm9sbCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjcm9sbExlZnQgPSAwIGFsc28gc2VlbXMgdG8gaWdub3JlIFJUTCBhbmQgbWFudWFsbHkgY2hlY2tpbmcgZm9yIFJUTCBpcyB0b28gbXVjaCBoYXNzbGUgc28gd2Ugd2lsbCBzY3JvbGwganVzdCB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbCB0byBkb21Ob2RlIGlmIGRvbU5vZGUgaXMgbm90IGluIHZpZXdwb3J0IHdoZW4gc2Nyb2xsZWQgdG8gdG9wIG9mIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChkb21Ob2RlLCB2aWV3cG9ydEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBmb3JjZSBsYXlvdXQgYnkgcXVlcnlpbmcgZG9tTm9kZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBkb250Rm9yY2VMYXlvdXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlIYXNoQ2hhbmdlOiBmb2N1c0FuZFNjcm9sbFJlZi5vbmx5SGFzaENoYW5nZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE11dGF0ZSBhZnRlciBzY3JvbGxpbmcgc28gdGhhdCBpdCBjYW4gYmUgcmVhZCBieSBgaGFuZGxlU21vb3RoU2Nyb2xsYFxuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLm9ubHlIYXNoQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIFNjcm9sbEFuZEZvY3VzSGFuZGxlcihwYXJhbSkge1xuICAgIGxldCB7IHNlZ21lbnRQYXRoLCBjaGlsZHJlbiB9ID0gcGFyYW07XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbm5lclNjcm9sbEFuZEZvY3VzSGFuZGxlciwge1xuICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBjb250ZXh0LmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cbi8qKlxuICogSW5uZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyByZW5kZXJpbmcgdGhlIHByb3ZpZGVkIHNlZ21lbnQgYmFzZWQgb24gdGhlIGNhY2hlLlxuICovIGZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgcGFyYWxsZWxSb3V0ZXJLZXksIHVybCwgY2hpbGROb2Rlcywgc2VnbWVudFBhdGgsIHRyZWUsIC8vIFRPRE8tQVBQOiBpbXBsZW1lbnQgYDxPZmZzY3JlZW4+YCB3aGVuIGF2YWlsYWJsZS5cbiAgICAvLyBpc0FjdGl2ZSxcbiAgICBjYWNoZUtleSB9ID0gcGFyYW07XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1aWxkSWQsIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsIHRyZWU6IGZ1bGxUcmVlIH0gPSBjb250ZXh0O1xuICAgIC8vIFJlYWQgc2VnbWVudCBwYXRoIGZyb20gdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlLlxuICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLmdldChjYWNoZUtleSk7XG4gICAgLy8gV2hlbiBkYXRhIGlzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHJlbmRlcmluZyBjbGllbnQtc2lkZSB3ZSBuZWVkIHRvIGZldGNoXG4gICAgLy8gaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgIGlmIChjaGlsZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXdMYXp5Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAgICAgICByc2M6IG51bGwsXG4gICAgICAgICAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IG51bGwsXG4gICAgICAgICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgbG9hZGluZzogbnVsbFxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2RlID0gbmV3TGF6eUNhY2hlTm9kZTtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQoY2FjaGVLZXksIG5ld0xhenlDYWNoZU5vZGUpO1xuICAgIH1cbiAgICAvLyBgcnNjYCByZXByZXNlbnRzIHRoZSByZW5kZXJhYmxlIG5vZGUgZm9yIHRoaXMgc2VnbWVudC5cbiAgICAvLyBJZiB0aGlzIHNlZ21lbnQgaGFzIGEgYHByZWZldGNoUnNjYCwgaXQncyB0aGUgc3RhdGljYWxseSBwcmVmZXRjaGVkIGRhdGEuXG4gICAgLy8gV2Ugc2hvdWxkIHVzZSB0aGF0IG9uIGluaXRpYWwgcmVuZGVyIGluc3RlYWQgb2YgYHJzY2AuIFRoZW4gd2UnbGwgc3dpdGNoXG4gICAgLy8gdG8gYHJzY2Agd2hlbiB0aGUgZHluYW1pYyByZXNwb25zZSBzdHJlYW1zIGluLlxuICAgIC8vXG4gICAgLy8gSWYgbm8gcHJlZmV0Y2ggZGF0YSBpcyBhdmFpbGFibGUsIHRoZW4gd2UgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIGByc2NgLlxuICAgIGNvbnN0IHJlc29sdmVkUHJlZmV0Y2hSc2MgPSBjaGlsZE5vZGUucHJlZmV0Y2hSc2MgIT09IG51bGwgPyBjaGlsZE5vZGUucHJlZmV0Y2hSc2MgOiBjaGlsZE5vZGUucnNjO1xuICAgIC8vIFdlIHVzZSBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gaGFuZGxlIHN3aXRjaGluZyBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZFxuICAgIC8vIGZpbmFsIHZhbHVlcy4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyByZXR1cm5lZCBvbiBpbml0aWFsIHJlbmRlciwgdGhlbiBpdFxuICAgIC8vIHJlLXJlbmRlcnMgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgLy9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYHVzZURlZmVycmVkVmFsdWVgIGlzIG9ubHlcbiAgICAvLyBhdmFpbGFibGUgaW4gdGhlIGV4cGVyaW1lbnRhbCBidWlsZHMuIFdoZW4gaXRzIGRpc2FibGVkLCBpdCB3aWxsIGFsd2F5c1xuICAgIC8vIHJldHVybiBgcnNjYC5cbiAgICBjb25zdCByc2MgPSAoMCwgX3JlYWN0LnVzZURlZmVycmVkVmFsdWUpKGNoaWxkTm9kZS5yc2MsIHJlc29sdmVkUHJlZmV0Y2hSc2MpO1xuICAgIC8vIGByc2NgIGlzIGVpdGhlciBhIFJlYWN0IG5vZGUgb3IgYSBwcm9taXNlIGZvciBhIFJlYWN0IG5vZGUsIGV4Y2VwdCB3ZVxuICAgIC8vIHNwZWNpYWwgY2FzZSBgbnVsbGAgdG8gcmVwcmVzZW50IHRoYXQgdGhpcyBzZWdtZW50J3MgZGF0YSBpcyBtaXNzaW5nLiBJZlxuICAgIC8vIGl0J3MgYSBwcm9taXNlLCB3ZSBuZWVkIHRvIHVud3JhcCBpdCBzbyB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgIC8vIGRhdGEgaXMgbWlzc2luZy5cbiAgICBjb25zdCByZXNvbHZlZFJzYyA9IHR5cGVvZiByc2MgPT09ICdvYmplY3QnICYmIHJzYyAhPT0gbnVsbCAmJiB0eXBlb2YgcnNjLnRoZW4gPT09ICdmdW5jdGlvbicgPyAoMCwgX3JlYWN0LnVzZSkocnNjKSA6IHJzYztcbiAgICBpZiAoIXJlc29sdmVkUnNjKSB7XG4gICAgICAgIC8vIFRoZSBkYXRhIGZvciB0aGlzIHNlZ21lbnQgaXMgbm90IGF2YWlsYWJsZSwgYW5kIHRoZXJlJ3Mgbm8gcGVuZGluZ1xuICAgICAgICAvLyBuYXZpZ2F0aW9uIHRoYXQgd2lsbCBiZSBhYmxlIHRvIGZ1bGZpbGwgaXQuIFdlIG5lZWQgdG8gZmV0Y2ggbW9yZSBmcm9tXG4gICAgICAgIC8vIHRoZSBzZXJ2ZXIgYW5kIHBhdGNoIHRoZSBjYWNoZS5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyByZXF1ZXN0LlxuICAgICAgICBsZXQgbGF6eURhdGEgPSBjaGlsZE5vZGUubGF6eURhdGE7XG4gICAgICAgIGlmIChsYXp5RGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBSb3V0ZXIgc3RhdGUgd2l0aCByZWZldGNoIG1hcmtlciBhZGRlZFxuICAgICAgICovIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgIGNvbnN0IHJlZmV0Y2hUcmVlID0gd2Fsa0FkZFJlZmV0Y2goW1xuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgIC4uLnNlZ21lbnRQYXRoXG4gICAgICAgICAgICBdLCBmdWxsVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlTmV4dFVybCA9ICgwLCBfaGFzaW50ZXJjZXB0aW9ucm91dGVpbmN1cnJlbnR0cmVlLmhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSkoZnVsbFRyZWUpO1xuICAgICAgICAgICAgY2hpbGROb2RlLmxhenlEYXRhID0gbGF6eURhdGEgPSAoMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksIHtcbiAgICAgICAgICAgICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogcmVmZXRjaFRyZWUsXG4gICAgICAgICAgICAgICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBjb250ZXh0Lm5leHRVcmwgOiBudWxsLFxuICAgICAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgICAgIH0pLnRoZW4oKHNlcnZlclJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVhY3Quc3RhcnRUcmFuc2l0aW9uKSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJlZTogZnVsbFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyUmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdXNwZW5kIGluZmluaXRlbHkgYXMgYGNoYW5nZUJ5U2VydmVyUmVzcG9uc2VgIHdpbGwgY2F1c2UgYSBkaWZmZXJlbnQgcGFydCBvZiB0aGUgdHJlZSB0byBiZSByZW5kZXJlZC5cbiAgICAgICAgLy8gQSBmYWxzZXkgYHJlc29sdmVkUnNjYCBpbmRpY2F0ZXMgbWlzc2luZyBkYXRhIC0tIHdlIHNob3VsZCBub3QgY29tbWl0IHRoYXQgYnJhbmNoLCBhbmQgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgZGF0YSB0byBhcnJpdmUuXG4gICAgICAgICgwLCBfcmVhY3QudXNlKShfdW5yZXNvbHZlZHRoZW5hYmxlLnVucmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgfVxuICAgIC8vIElmIHdlIGdldCB0byB0aGlzIHBvaW50LCB0aGVuIHdlIGtub3cgd2UgaGF2ZSBzb21ldGhpbmcgd2UgY2FuIHJlbmRlci5cbiAgICBjb25zdCBzdWJ0cmVlID0gLy8gVGhlIGxheW91dCByb3V0ZXIgY29udGV4dCBuYXJyb3dzIGRvd24gdHJlZSBhbmQgY2hpbGROb2RlcyBhdCBlYWNoIGxldmVsLlxuICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgbG9hZGluZzogY2hpbGROb2RlLmxvYWRpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IHJlc29sdmVkUnNjXG4gICAgfSk7XG4gICAgLy8gRW5zdXJlIHJvb3QgbGF5b3V0IGlzIG5vdCB3cmFwcGVkIGluIGEgZGl2IGFzIHRoZSByb290IGxheW91dCByZW5kZXJzIGA8aHRtbD5gXG4gICAgcmV0dXJuIHN1YnRyZWU7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4sIGhhc0xvYWRpbmcsIGxvYWRpbmcsIGxvYWRpbmdTdHlsZXMsIGxvYWRpbmdTY3JpcHRzIH0gPSBwYXJhbTtcbiAgICAvLyBXZSBoYXZlIGFuIGV4cGxpY2l0IHByb3AgZm9yIGNoZWNraW5nIGlmIGBsb2FkaW5nYCBpcyBwcm92aWRlZCwgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gYSBsb2FkaW5nXG4gICAgLy8gY29tcG9uZW50IHRoYXQgcmV0dXJucyBgbnVsbGAgLyBgdW5kZWZpbmVkYCwgdnMgbm90IGhhdmluZyBhIGxvYWRpbmcgY29tcG9uZW50IGF0IGFsbC5cbiAgICBpZiAoaGFzTG9hZGluZykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfcmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShfanN4cnVudGltZS5GcmFnbWVudCwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdTY3JpcHRzLFxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuZnVuY3Rpb24gT3V0ZXJMYXlvdXRSb3V0ZXIocGFyYW0pIHtcbiAgICBsZXQgeyBwYXJhbGxlbFJvdXRlcktleSwgc2VnbWVudFBhdGgsIGVycm9yLCBlcnJvclN0eWxlcywgZXJyb3JTY3JpcHRzLCB0ZW1wbGF0ZVN0eWxlcywgdGVtcGxhdGVTY3JpcHRzLCB0ZW1wbGF0ZSwgbm90Rm91bmQsIG5vdEZvdW5kU3R5bGVzIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGV4cGVjdGVkIGxheW91dCByb3V0ZXIgdG8gYmUgbW91bnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkTm9kZXMsIHRyZWUsIHVybCwgbG9hZGluZyB9ID0gY29udGV4dDtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYWxsZWxSb3V0ZXIgY2FjaGUgbm9kZVxuICAgIGxldCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBjaGlsZE5vZGVzLmdldChwYXJhbGxlbFJvdXRlcktleSk7XG4gICAgLy8gSWYgdGhlIHBhcmFsbGVsIHJvdXRlciBjYWNoZSBub2RlIGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LlxuICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgIGlmICghY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyKSB7XG4gICAgICAgIGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQocGFyYWxsZWxSb3V0ZXJLZXksIGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcik7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgYWN0aXZlIHNlZ21lbnQgaW4gdGhlIHRyZWVcbiAgICAvLyBUaGUgcmVhc29uIGFycmF5cyBhcmUgdXNlZCBpbiB0aGUgZGF0YSBmb3JtYXQgaXMgdGhhdCB0aGVzZSBhcmUgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBicm93c2VyIHNvIGl0J3Mgb3B0aW1pemVkIHRvIHNhdmUgYnl0ZXMuXG4gICAgY29uc3QgdHJlZVNlZ21lbnQgPSB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XVswXTtcbiAgICAvLyBJZiBzZWdtZW50IGlzIGFuIGFycmF5IGl0J3MgYSBkeW5hbWljIHJvdXRlIGFuZCB3ZSB3YW50IHRvIHJlYWQgdGhlIGR5bmFtaWMgcm91dGUgdmFsdWUgYXMgdGhlIHNlZ21lbnQgdG8gZ2V0IGZyb20gdGhlIGNhY2hlLlxuICAgIGNvbnN0IGN1cnJlbnRDaGlsZFNlZ21lbnRWYWx1ZSA9ICgwLCBfZ2V0c2VnbWVudHZhbHVlLmdldFNlZ21lbnRWYWx1ZSkodHJlZVNlZ21lbnQpO1xuICAgIC8qKlxuICAgKiBEZWNpZGVzIHdoaWNoIHNlZ21lbnRzIHRvIGtlZXAgcmVuZGVyaW5nLCBhbGwgc2VnbWVudHMgdGhhdCBhcmUgbm90IGFjdGl2ZSB3aWxsIGJlIHdyYXBwZWQgaW4gYDxPZmZzY3JlZW4+YC5cbiAgICovIC8vIFRPRE8tQVBQOiBBZGQgaGFuZGxpbmcgb2YgYDxPZmZzY3JlZW4+YCB3aGVuIGl0J3MgYXZhaWxhYmxlLlxuICAgIGNvbnN0IHByZXNlcnZlZFNlZ21lbnRzID0gW1xuICAgICAgICB0cmVlU2VnbWVudFxuICAgIF07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IHByZXNlcnZlZFNlZ21lbnRzLm1hcCgocHJlc2VydmVkU2VnbWVudCk9PntcbiAgICAgICAgICAgIGNvbnN0IHByZXNlcnZlZFNlZ21lbnRWYWx1ZSA9ICgwLCBfZ2V0c2VnbWVudHZhbHVlLmdldFNlZ21lbnRWYWx1ZSkocHJlc2VydmVkU2VnbWVudCk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9ICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHByZXNlcnZlZFNlZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuKC8qXG4gICAgICAgICAgICAtIEVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIGVycm9yIGJvdW5kYXJ5IGlmIGVycm9yIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgLSBMb2FkaW5nIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIHN1c3BlbnNlIGJvdW5kYXJ5IGlmIGxvYWRpbmcgY29tcG9uZW50cyBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgIC0gUGFzc2VkIHRvIHRoZSByb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyB0byBlbnN1cmUgaXQgY2FuIGJlIGltbWVkaWF0ZWx5IHJlbmRlcmVkIHdoZW4gc3VzcGVuZGluZyBvbiBhIEZsaWdodCBmZXRjaC5cbiAgICAgICAgICAqLyAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuVGVtcGxhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoU2Nyb2xsQW5kRm9jdXNIYW5kbGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2Vycm9yYm91bmRhcnkuRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTdHlsZXM6IGVycm9yU3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTY3JpcHRzOiBlcnJvclNjcmlwdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShMb2FkaW5nQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNMb2FkaW5nOiBCb29sZWFuKGxvYWRpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlczogbG9hZGluZyA9PSBudWxsID8gdm9pZCAwIDogbG9hZGluZ1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nU2NyaXB0czogbG9hZGluZyA9PSBudWxsID8gdm9pZCAwIDogbG9hZGluZ1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfbm90Zm91bmRib3VuZGFyeS5Ob3RGb3VuZEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRTdHlsZXM6IG5vdEZvdW5kU3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfcmVkaXJlY3Rib3VuZGFyeS5SZWRpcmVjdEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbm5lckxheW91dFJvdXRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVyS2V5OiBwYXJhbGxlbFJvdXRlcktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUgPT09IHByZXNlcnZlZFNlZ21lbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVTY3JpcHRzLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHByZXNlcnZlZFNlZ21lbnQsIHRydWUpKSk7XG4gICAgICAgIH0pXG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIk91dGVyTGF5b3V0Um91dGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVhY3Rkb20iLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfZmV0Y2hzZXJ2ZXJyZXNwb25zZSIsIl91bnJlc29sdmVkdGhlbmFibGUiLCJfZXJyb3Jib3VuZGFyeSIsIl9tYXRjaHNlZ21lbnRzIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsIl9yZWRpcmVjdGJvdW5kYXJ5IiwiX25vdGZvdW5kYm91bmRhcnkiLCJfZ2V0c2VnbWVudHZhbHVlIiwiX2NyZWF0ZXJvdXRlcmNhY2hla2V5IiwiX2hhc2ludGVyY2VwdGlvbnJvdXRlaW5jdXJyZW50dHJlZSIsIndhbGtBZGRSZWZldGNoIiwic2VnbWVudFBhdGhUb1dhbGsiLCJ0cmVlVG9SZWNyZWF0ZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwiaXNMYXN0IiwibGVuZ3RoIiwibWF0Y2hTZWdtZW50IiwiaGFzT3duUHJvcGVydHkiLCJzdWJUcmVlIiwidW5kZWZpbmVkIiwic2xpY2UiLCJfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJkZWZhdWx0IiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsIndpbmRvdyIsImludGVybmFsX3JlYWN0RE9NZmluZERPTU5vZGUiLCJyZWN0UHJvcGVydGllcyIsInNob3VsZFNraXBFbGVtZW50IiwiZWxlbWVudCIsImluY2x1ZGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsIndhcm4iLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZXZlcnkiLCJpdGVtIiwidG9wT2ZFbGVtZW50SW5WaWV3cG9ydCIsInZpZXdwb3J0SGVpZ2h0IiwidG9wIiwiZ2V0SGFzaEZyYWdtZW50RG9tTm9kZSIsImhhc2hGcmFnbWVudCIsImRvY3VtZW50IiwiYm9keSIsIl9kb2N1bWVudF9nZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJJbm5lclNjcm9sbEFuZEZvY3VzSGFuZGxlciIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiaGFuZGxlUG90ZW50aWFsU2Nyb2xsIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJvcHMiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJzZWdtZW50UGF0aCIsInNlZ21lbnRQYXRocyIsInNvbWUiLCJzY3JvbGxSZWZTZWdtZW50UGF0aCIsImluZGV4IiwiZG9tTm9kZSIsIkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIm5leHRFbGVtZW50U2libGluZyIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbEludG9WaWV3IiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxUb3AiLCJkb250Rm9yY2VMYXlvdXQiLCJvbmx5SGFzaENoYW5nZSIsImZvY3VzIiwiU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIiwicGFyYW0iLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJFcnJvciIsImpzeCIsIklubmVyTGF5b3V0Um91dGVyIiwicGFyYWxsZWxSb3V0ZXJLZXkiLCJ1cmwiLCJjaGlsZE5vZGVzIiwidHJlZSIsImNhY2hlS2V5IiwiYnVpbGRJZCIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmdWxsVHJlZSIsImNoaWxkTm9kZSIsIm5ld0xhenlDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwibG9hZGluZyIsInNldCIsInJlc29sdmVkUHJlZmV0Y2hSc2MiLCJ1c2VEZWZlcnJlZFZhbHVlIiwicmVzb2x2ZWRSc2MiLCJ0aGVuIiwidXNlIiwicmVmZXRjaFRyZWUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInNlcnZlclJlc3BvbnNlIiwic3RhcnRUcmFuc2l0aW9uIiwicHJldmlvdXNUcmVlIiwidW5yZXNvbHZlZFRoZW5hYmxlIiwic3VidHJlZSIsIkxheW91dFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIkxvYWRpbmdCb3VuZGFyeSIsImhhc0xvYWRpbmciLCJsb2FkaW5nU3R5bGVzIiwibG9hZGluZ1NjcmlwdHMiLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwianN4cyIsIkZyYWdtZW50IiwiZXJyb3IiLCJlcnJvclN0eWxlcyIsImVycm9yU2NyaXB0cyIsInRlbXBsYXRlU3R5bGVzIiwidGVtcGxhdGVTY3JpcHRzIiwidGVtcGxhdGUiLCJub3RGb3VuZCIsIm5vdEZvdW5kU3R5bGVzIiwiY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyIiwidHJlZVNlZ21lbnQiLCJjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUiLCJnZXRTZWdtZW50VmFsdWUiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsIm1hcCIsInByZXNlcnZlZFNlZ21lbnQiLCJwcmVzZXJ2ZWRTZWdtZW50VmFsdWUiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsIlRlbXBsYXRlQ29udGV4dCIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIkJvb2xlYW4iLCJOb3RGb3VuZEJvdW5kYXJ5IiwiUmVkaXJlY3RCb3VuZGFyeSIsImlzQWN0aXZlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = RenderFromTemplateContext;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxVQUFVLEVBQUUsSUFBSTtJQUNoQkMsR0FBRyxFQUFFLFNBQUFBLENBQUEsRUFBVztRQUNaLE9BQU9DLHlCQUF5QjtJQUNwQztBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLHlCQUF5QixHQUFHQyxtQkFBTyxDQUFDLGtJQUEwQyxDQUFDO0FBQ3JGLE1BQU1DLFdBQVcsR0FBR0QsbUJBQU8sQ0FBQyxxR0FBbUIsQ0FBQztBQUNoRCxNQUFNRSxNQUFNLEdBQUcsY0FBY0gseUJBQXlCLENBQUNJLENBQUMsQ0FBQ0gsbUJBQU8sQ0FBQyxtRkFBTyxDQUFDLENBQUM7QUFDMUUsTUFBTUksOEJBQThCLEdBQUdKLG1CQUFPLENBQUMsd0pBQW9ELENBQUM7QUFDcEc7SUFDSSxNQUFNSyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEVBQUVILE1BQU0sQ0FBQ0ksVUFBQUEsRUFBWUYsOEJBQThCLENBQUNHLGVBQWUsQ0FBQztJQUN2RixPQUFPLGVBQWUsQ0FBQyxFQUFFTixXQUFXLENBQUNPLEdBQUFBLEVBQUtQLFdBQVcsQ0FBQ1EsUUFBUSxFQUFFO1FBQzVESixRQUFRLEVBQUVBO0lBQ2QsQ0FBQyxDQUFDO0FBQ047S0FMU1AseUJBQXlCQSxDQUFBO0FBT2xDLElBQUksQ0FBQyxPQUFPSixPQUFPLENBQUNnQixPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU9oQixPQUFPLENBQUNnQixPQUFPLEtBQUssUUFBUSxJQUFJaEIsT0FBTyxDQUFDZ0IsT0FBTyxLQUFLLEtBQUssSUFBSyxPQUFPaEIsT0FBTyxDQUFDZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssV0FBVyxFQUFFO0lBQ3JLbkIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sQ0FBQ2dCLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRWYsS0FBSyxFQUFFO0lBQUssQ0FBQyxDQUFDO0lBQ3JFSCxNQUFNLENBQUNvQixNQUFNLENBQUNsQixPQUFPLENBQUNnQixPQUFPLEVBQUVoQixPQUFPLENBQUM7SUFDdkNtQixNQUFNLENBQUNuQixPQUFPLEdBQUdBLE9BQU8sQ0FBQ2dCLE9BQU87QUFDbEMiLCJzb3VyY2VzIjpbIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuZnVuY3Rpb24gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlRlbXBsYXRlQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsImNoaWxkcmVuIiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsImpzeCIsIkZyYWdtZW50IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/invariant-error.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"InvariantError\", ({\n    enumerable: true,\n    get: function() {\n        return InvariantError;\n    }\n}));\nclass InvariantError extends Error {\n    constructor(message, options){\n        super(\"Invariant: \" + (message.endsWith('.') ? message : message + '.') + \" This is a bug in Next.js.\", options);\n        this.name = 'InvariantError';\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxVQUFVLEVBQUUsSUFBSTtJQUNoQkMsR0FBRyxFQUFFLFNBQUFBLENBQUEsRUFBVztRQUNaLE9BQU9DLGNBQWM7SUFDekI7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQSxjQUFjLFNBQVNDLEtBQUssQ0FBQztJQUMvQkMsV0FBV0EsQ0FBQ0MsT0FBTyxFQUFFQyxPQUFPLENBQUM7UUFDekIsS0FBSyxDQUFDLGFBQWEsSUFBSUQsT0FBTyxDQUFDRSxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUdGLE9BQU8sR0FBR0EsT0FBTyxHQUFHLElBQUcsQ0FBQyxFQUFHLDRCQUE0QixFQUFFQyxPQUFPLENBQUM7UUFDaEgsSUFBSSxDQUFDRSxJQUFJLEdBQUcsZ0JBQWdCO0lBQ2hDO0FBQ0oiLCJzb3VyY2VzIjpbIi9ob21lL21heC9kZXYvcHJpc21hLWZhcm1hY2lhL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnZhcmlhbnRFcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSW52YXJpYW50RXJyb3I7XG4gICAgfVxufSk7XG5jbGFzcyBJbnZhcmlhbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIoXCJJbnZhcmlhbnQ6IFwiICsgKG1lc3NhZ2UuZW5kc1dpdGgoJy4nKSA/IG1lc3NhZ2UgOiBtZXNzYWdlICsgJy4nKSArIFwiIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qcy5cIiwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhcmlhbnRFcnJvcic7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhcmlhbnQtZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkludmFyaWFudEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiZW5kc1dpdGgiLCJuYW1lIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSmoothScroll\", ({\n    enumerable: true,\n    get: function() {\n        return handleSmoothScroll;\n    }\n}));\nfunction handleSmoothScroll(fn, options) {\n    if (options === void 0) options = {};\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = 'auto';\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGwuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdBLEdBQWlCO0FBQ2pCQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxzREFBcUQ7SUFDakRJLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO1FBQ1osT0FBT0Msa0JBQWtCO0lBQzdCO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0Esa0JBQWtCQSxDQUFDQyxFQUFFLEVBQUVDLE9BQU8sRUFBRTtJQUNyQyxJQUFJQSxPQUFPLEtBQUssS0FBSyxDQUFDLEVBQUVBLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDcEM7SUFDQTtJQUNBLElBQUlBLE9BQU8sQ0FBQ0MsY0FBYyxFQUFFO1FBQ3hCRixFQUFFLENBQUMsQ0FBQztRQUNKO0lBQ0o7SUFDQSxNQUFNRyxXQUFXLEdBQUdDLFFBQVEsQ0FBQ0MsZUFBZTtJQUM1QyxNQUFNQyxRQUFRLEdBQUdILFdBQVcsQ0FBQ0ksS0FBSyxDQUFDQyxjQUFjO0lBQ2pETCxXQUFXLENBQUNJLEtBQUssQ0FBQ0MsY0FBYyxHQUFHLE1BQU07SUFDekMsSUFBSSxDQUFDUCxPQUFPLENBQUNRLGVBQWUsRUFBRTtRQUMxQjtRQUNBO1FBQ0E7UUFDQU4sV0FBVyxDQUFDTyxjQUFjLENBQUMsQ0FBQztJQUNoQztJQUNBVixFQUFFLENBQUMsQ0FBQztJQUNKRyxXQUFXLENBQUNJLEtBQUssQ0FBQ0MsY0FBYyxHQUFHRixRQUFRO0FBQy9DIiwic291cmNlcyI6WyIvaG9tZS9tYXgvZGV2L3ByaXNtYS1mYXJtYWNpYS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUnVuIGZ1bmN0aW9uIHdpdGggYHNjcm9sbC1iZWhhdmlvcjogYXV0b2AgYXBwbGllZCB0byBgPGh0bWwvPmAuXG4gKiBUaGlzIGNzcyBjaGFuZ2Ugd2lsbCBiZSByZXZlcnRlZCBhZnRlciB0aGUgZnVuY3Rpb24gZmluaXNoZXMuXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYW5kbGVTbW9vdGhTY3JvbGxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVNtb290aFNjcm9sbDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVNtb290aFNjcm9sbChmbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAvLyBpZiBvbmx5IHRoZSBoYXNoIGlzIGNoYW5nZWQsIHdlIGRvbid0IG5lZWQgdG8gZGlzYWJsZSBzbW9vdGggc2Nyb2xsaW5nXG4gICAgLy8gd2Ugb25seSBjYXJlIHRvIHByZXZlbnQgc21vb3RoIHNjcm9sbGluZyB3aGVuIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSB0byBhdm9pZCBqYXJyaW5nIFVYXG4gICAgaWYgKG9wdGlvbnMub25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBjb25zdCBleGlzdGluZyA9IGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ2F1dG8nO1xuICAgIGlmICghb3B0aW9ucy5kb250Rm9yY2VMYXlvdXQpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLWJhc2VkIGJyb3dzZXJzIHdlIG5lZWQgdG8gZm9yY2UgcmVmbG93IGJlZm9yZSBjYWxsaW5nIGBzY3JvbGxUb2AuXG4gICAgICAgIC8vIE90aGVyd2lzZSBpdCB3aWxsIG5vdCBwaWNrdXAgdGhlIGNoYW5nZSBpbiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MDcxOSNpc3N1ZWNvbW1lbnQtMTMzNjI0ODA0MlxuICAgICAgICBodG1sRWxlbWVudC5nZXRDbGllbnRSZWN0cygpO1xuICAgIH1cbiAgICBmbigpO1xuICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbmRsZS1zbW9vdGgtc2Nyb2xsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJmbiIsIm9wdGlvbnMiLCJvbmx5SGFzaENoYW5nZSIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJkb250Rm9yY2VMYXlvdXQiLCJnZXRDbGllbnRSZWN0cyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fnot-found-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Fmax%2Fdev%2Fprisma-farmacia%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);